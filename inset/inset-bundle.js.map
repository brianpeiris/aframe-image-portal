{
  "version": 3,
  "sources": ["../node_modules/@flatten-js/core/dist/main.esm.js", "../node_modules/@flatten-js/polygon-offset/dist/main.esm.js", "index.js"],
  "sourcesContent": ["/**\n * Global constant CCW defines counter clockwise direction of arc\n * @type {boolean}\n */\nconst CCW = true;\n\n/**\n * Global constant CW defines clockwise direction of arc\n * @type {boolean}\n */\nconst CW = false;\n\n/**\n * Defines orientation for face of the polygon: clockwise, counter clockwise\n * or not orientable in the case of self-intersection\n * @type {{CW: number, CCW: number, NOT_ORIENTABLE: number}}\n */\nconst ORIENTATION = {CCW:-1, CW:1, NOT_ORIENTABLE: 0};\n\nconst PIx2 = 2 * Math.PI;\n\nconst INSIDE = 1;\nconst OUTSIDE = 0;\nconst BOUNDARY = 2;\nconst CONTAINS = 3;\nconst INTERLACE = 4;\n\nconst OVERLAP_SAME = 1;\nconst OVERLAP_OPPOSITE = 2;\n\nvar Constants = /*#__PURE__*/Object.freeze({\n    CCW: CCW,\n    CW: CW,\n    ORIENTATION: ORIENTATION,\n    PIx2: PIx2,\n    INSIDE: INSIDE,\n    OUTSIDE: OUTSIDE,\n    BOUNDARY: BOUNDARY,\n    CONTAINS: CONTAINS,\n    INTERLACE: INTERLACE,\n    OVERLAP_SAME: OVERLAP_SAME,\n    OVERLAP_OPPOSITE: OVERLAP_OPPOSITE\n});\n\n/**\n * Created by Alex Bol on 2/18/2017.\n */\n\n/**\n * Floating point comparison tolerance.\n * Default value is 0.000001 (10e-6)\n * @type {number}\n */\nlet DP_TOL = 0.000001;\n\n/**\n * Set new floating point comparison tolerance\n * @param {number} tolerance\n */\nfunction setTolerance(tolerance) {DP_TOL = tolerance;}\n\n/**\n * Get floating point comparison tolerance\n * @returns {number}\n */\nfunction getTolerance() {return DP_TOL;}\n\nconst DECIMALS = 3;\n\n/**\n * Returns *true* if value comparable to zero\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction EQ_0(x) {\n    return (x < DP_TOL && x > -DP_TOL);\n}\n\n/**\n * Returns *true* if two values are equal up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction EQ(x, y) {\n    return (x - y < DP_TOL && x - y > -DP_TOL);\n}\n\n/**\n * Returns *true* if first argument greater than second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction GT(x, y) {\n    return (x - y > DP_TOL);\n}\n\n/**\n * Returns *true* if first argument greater than or equal to second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @returns {boolean}\n */\nfunction GE(x, y) {\n    return (x - y > -DP_TOL);\n}\n\n/**\n * Returns *true* if first argument less than second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction LT(x, y) {\n    return (x - y < -DP_TOL)\n}\n\n/**\n * Returns *true* if first argument less than or equal to second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction LE(x, y) {\n    return (x - y < DP_TOL);\n}\n\nvar Utils = /*#__PURE__*/Object.freeze({\n    setTolerance: setTolerance,\n    getTolerance: getTolerance,\n    DECIMALS: DECIMALS,\n    EQ_0: EQ_0,\n    EQ: EQ,\n    GT: GT,\n    GE: GE,\n    LT: LT,\n    LE: LE\n});\n\n/**\n * Created by Alex Bol on 2/19/2017.\n */\n\n/**\n * Class of system errors\n */\nclass Errors {\n    /**\n     * Throw error ILLEGAL_PARAMETERS when cannot instantiate from given parameter\n     * @returns {ReferenceError}\n     */\n    static get ILLEGAL_PARAMETERS() {\n        return new ReferenceError('Illegal Parameters');\n    }\n\n    /**\n     * Throw error ZERO_DIVISION to catch situation of zero division\n     * @returns {Error}\n     */\n    static get ZERO_DIVISION() {\n        return new Error('Zero division');\n    }\n\n    /**\n     * Error to throw from BooleanOperations module in case when fixBoundaryConflicts not capable to fix it\n     * @returns {Error}\n     */\n    static get UNRESOLVED_BOUNDARY_CONFLICT() {\n        return new Error('Unresolved boundary conflict in boolean operation');\n    }\n\n    /**\n     * Error to throw from LinkedList:testInfiniteLoop static method\n     * in case when circular loop detected in linked list\n     * @returns {Error}\n     */\n    static get INFINITE_LOOP() {\n        return new Error('Infinite loop');\n    }\n}\n\nvar errors = /*#__PURE__*/Object.freeze({\n    default: Errors\n});\n\nlet Flatten = {\n    Utils: Utils,\n    Errors: Errors,\n    Matrix: undefined,\n    Planar_set: undefined,\n    Point: undefined,\n    Vector: undefined,\n    Line: undefined,\n    Circle: undefined,\n    Segment: undefined,\n    Arc: undefined,\n    Box: undefined,\n    Edge: undefined,\n    Face: undefined,\n    Ray: undefined,\n    Ray_shooting: undefined,\n    Multiline: undefined,\n    Polygon: undefined,\n    Distance: undefined,\n};\n\nfor (let c in Constants) {Flatten[c] = Constants[c];}\n\nObject.defineProperty(Flatten, 'DP_TOL', {\n    get:function(){return getTolerance()}, \n    set:function(value){setTolerance(value);}\n});\n\n/**\n * Class implements bidirectional non-circular linked list. <br/>\n * LinkedListElement - object of any type that has properties next and prev.\n */\nclass LinkedList {\n    constructor(first, last) {\n        this.first = first;\n        this.last = last || this.first;\n    }\n\n    /**\n     * Throw an error if circular loop detected in the linked list\n     * @param {LinkedListElement} first element to start iteration\n     * @throws {Flatten.Errors.INFINITE_LOOP}\n     */\n    static testInfiniteLoop(first) {\n        let edge = first;\n        let controlEdge = first;\n        do {\n            if (edge != first && edge === controlEdge) {\n                throw Flatten.Errors.INFINITE_LOOP;  // new Error(\"Infinite loop\")\n            }\n            edge = edge.next;\n            controlEdge = controlEdge.next.next;\n        } while (edge != first)\n    }\n\n    /**\n     * Return number of elements in the list\n     * @returns {number}\n     */\n    get size() {\n        let counter = 0;\n        for (let edge of this) {\n            counter++;\n        }\n        return counter;\n    }\n\n    /**\n     * Return array of elements from start to end,\n     * If start or end not defined, take first as start, last as end\n     * @returns {Array}\n     */\n    toArray(start=undefined, end=undefined) {\n        let elements = [];\n        let from = start || this.first;\n        let to = end || this.last;\n        let element = from;\n        if (element === undefined) return elements;\n        do {\n            elements.push(element);\n            element = element.next;\n        } while (element !== to.next);\n        return elements;\n    }\n\n\n    /**\n     * Append new element to the end of the list\n     * @param {LinkedListElement} element\n     * @returns {LinkedList}\n     */\n    append(element) {\n        if (this.isEmpty()) {\n            this.first = element;\n        } else {\n            element.prev = this.last;\n            this.last.next = element;\n        }\n\n        // update edge to be last\n        this.last = element;\n\n        // nullify non-circular links\n        this.last.next = undefined;\n        this.first.prev = undefined;\n        return this;\n    }\n\n    /**\n     * Insert new element to the list after elementBefore\n     * @param {LinkedListElement} newElement\n     * @param {LinkedListElement} elementBefore\n     * @returns {LinkedList}\n     */\n    insert(newElement, elementBefore) {\n        if (this.isEmpty()) {\n            this.first = newElement;\n            this.last = newElement;\n        }\n        else if (elementBefore === null || elementBefore === undefined) {\n            newElement.next = this.first;\n            this.first.prev = newElement;\n            this.first = newElement;\n        }\n        else {\n            /* set links to new element */\n            let elementAfter = elementBefore.next;\n            elementBefore.next = newElement;\n            if (elementAfter) elementAfter.prev = newElement;\n\n            /* set links from new element */\n            newElement.prev = elementBefore;\n            newElement.next = elementAfter;\n\n            /* extend list if new element added after the last element */\n            if (this.last === elementBefore)\n                this.last = newElement;\n        }\n        // nullify non-circular links\n        this.last.next = undefined;\n        this.first.prev = undefined;\n        return this;\n    }\n\n    /**\n     * Remove element from the list\n     * @param {LinkedListElement} element\n     * @returns {LinkedList}\n     */\n    remove(element) {\n        // special case if last edge removed\n        if (element === this.first && element === this.last) {\n            this.first = undefined;\n            this.last = undefined;\n        } else {\n            // update linked list\n            if (element.prev) element.prev.next = element.next;\n            if (element.next) element.next.prev = element.prev;\n            // update first if need\n            if (element === this.first) {\n                this.first = element.next;\n            }\n            // update last if need\n            if (element === this.last) {\n                this.last = element.prev;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Return true if list is empty\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return this.first === undefined;\n    }\n\n    [Symbol.iterator]() {\n        let value = undefined;\n        return {\n            next: () => {\n                value = value ? value.next : this.first;\n                return {value: value, done: value === undefined};\n            }\n        };\n    };\n}\n\n/**\n * Created by Alex Bol on 12/02/2018.\n */\n\nlet {INSIDE: INSIDE$1, OUTSIDE: OUTSIDE$1, BOUNDARY: BOUNDARY$1, OVERLAP_SAME: OVERLAP_SAME$1, OVERLAP_OPPOSITE: OVERLAP_OPPOSITE$1} = Flatten;\n\nconst NOT_VERTEX = 0;\nconst START_VERTEX = 1;\nconst END_VERTEX = 2;\n\nconst BOOLEAN_UNION = 1;\nconst BOOLEAN_INTERSECT = 2;\nconst BOOLEAN_SUBTRACT = 3;\n\n\n/**\n * Unify two polygons polygons and returns new polygon. <br/>\n * Point belongs to the resulted polygon if it belongs to the first OR to the second polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Polygon}\n */\nfunction unify(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_UNION, true);\n    return res_poly;\n}\n\n/**\n * Subtract second polygon from the first and returns new polygon\n * Point belongs to the resulted polygon if it belongs to the first polygon AND NOT to the second polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Polygon}\n */\nfunction subtract(polygon1, polygon2) {\n    let polygon2_tmp = polygon2.clone();\n    let polygon2_reversed = polygon2_tmp.reverse();\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2_reversed, BOOLEAN_SUBTRACT, true);\n    return res_poly;\n}\n\n/**\n * Intersect two polygons and returns new polygon\n * Point belongs to the resultes polygon is it belongs to the first AND to the second polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Polygon}\n */\nfunction intersect(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_INTERSECT, true);\n    return res_poly;\n}\n\n/**\n * Returns boundary of intersection between two polygons as two arrays of shapes (Segments/Arcs) <br/>\n * The first array are shapes from the first polygon, the second array are shapes from the second\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Shape[][]}\n */\nfunction innerClip(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_INTERSECT, false);\n\n    let clip_shapes1 = [];\n    for (let face of res_poly.faces) {\n        clip_shapes1 = [...clip_shapes1, ...[...face.edges].map(edge => edge.shape)];\n    }\n    let clip_shapes2 = [];\n    for (let face of wrk_poly.faces) {\n        clip_shapes2 = [...clip_shapes2, ...[...face.edges].map(edge => edge.shape)];\n    }\n    return [clip_shapes1, clip_shapes2];\n}\n\n/**\n * Returns boundary of subtraction of the second polygon from first polygon as array of shapes\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Shape[]}\n */\nfunction outerClip(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_SUBTRACT, false);\n\n    let clip_shapes1 = [];\n    for (let face of res_poly.faces) {\n        clip_shapes1 = [...clip_shapes1, ...[...face.edges].map(edge => edge.shape)];\n    }\n\n    return clip_shapes1;\n}\n\n/**\n * Returns intersection points between boundaries of two polygons as two array of points <br/>\n * Points in the first array belong to first polygon, points from the second - to the second.\n * Points in each array are ordered according to the direction of the correspondent polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Point[][]}\n */\nfunction calculateIntersections(polygon1, polygon2) {\n    let res_poly = polygon1.clone();\n    let wrk_poly = polygon2.clone();\n\n    // get intersection points\n    let intersections = getIntersections(res_poly, wrk_poly);\n\n    // sort intersection points\n    sortIntersections(intersections);\n\n    // split by intersection points\n    splitByIntersections(res_poly, intersections.int_points1_sorted);\n    splitByIntersections(wrk_poly, intersections.int_points2_sorted);\n\n    // filter duplicated intersection points\n    filterDuplicatedIntersections(intersections);\n\n    let ip_sorted1 = intersections.int_points1_sorted.map( int_point => int_point.pt);\n    let ip_sorted2 = intersections.int_points2_sorted.map( int_point => int_point.pt);\n    return [ip_sorted1, ip_sorted2];\n}\n\nfunction filterNotRelevantEdges(res_poly, wrk_poly, intersections, op) {\n    // keep not intersected faces for further remove and merge\n    let notIntersectedFacesRes = getNotIntersectedFaces(res_poly, intersections.int_points1);\n    let notIntersectedFacesWrk = getNotIntersectedFaces(wrk_poly, intersections.int_points2);\n\n    // calculate inclusion flag for not intersected faces\n    calcInclusionForNotIntersectedFaces(notIntersectedFacesRes, wrk_poly);\n    calcInclusionForNotIntersectedFaces(notIntersectedFacesWrk, res_poly);\n\n    // initialize inclusion flags for edges incident to intersections\n    initializeInclusionFlags(intersections.int_points1);\n    initializeInclusionFlags(intersections.int_points2);\n\n    // calculate inclusion flags only for edges incident to intersections\n    calculateInclusionFlags(intersections.int_points1, wrk_poly);\n    calculateInclusionFlags(intersections.int_points2, res_poly);\n\n    // fix boundary conflicts\n    while (fixBoundaryConflicts(res_poly, wrk_poly, intersections.int_points1, intersections.int_points1_sorted, intersections.int_points2, intersections));\n    // while (fixBoundaryConflicts(wrk_poly, res_poly, intersections.int_points2, intersections.int_points2_sorted, intersections.int_points1, intersections));\n\n    // Set overlapping flags for boundary chains: SAME or OPPOSITE\n    setOverlappingFlags(intersections);\n\n    // remove not relevant chains between intersection points\n    removeNotRelevantChains(res_poly, op, intersections.int_points1_sorted, true);\n    removeNotRelevantChains(wrk_poly, op, intersections.int_points2_sorted, false);\n\n    // remove not relevant not intersected faces from res_polygon and wrk_polygon\n    // if op == UNION, remove faces that are included in wrk_polygon without intersection\n    // if op == INTERSECT, remove faces that are not included into wrk_polygon\n    removeNotRelevantNotIntersectedFaces(res_poly, notIntersectedFacesRes, op, true);\n    removeNotRelevantNotIntersectedFaces(wrk_poly, notIntersectedFacesWrk, op, false);\n}\n\nfunction swapLinksAndRestore(res_poly, wrk_poly, intersections, op) {\n\n    // add edges of wrk_poly into the edge container of res_poly\n    copyWrkToRes(res_poly, wrk_poly, op, intersections.int_points2);\n\n    // swap links from res_poly to wrk_poly and vice versa\n    swapLinks(res_poly, wrk_poly, intersections);\n\n    // remove old faces\n    removeOldFaces(res_poly, intersections.int_points1);\n    removeOldFaces(wrk_poly, intersections.int_points2);\n\n    // restore faces\n    restoreFaces(res_poly, intersections.int_points1, intersections.int_points2);\n    restoreFaces(res_poly, intersections.int_points2, intersections.int_points1);\n\n    // merge relevant not intersected faces from wrk_polygon to res_polygon\n    // mergeRelevantNotIntersectedFaces(res_poly, wrk_poly);\n}\n\n\nfunction booleanOpBinary(polygon1, polygon2, op, restore)\n{\n    let res_poly = polygon1.clone();\n    let wrk_poly = polygon2.clone();\n\n    // get intersection points\n    let intersections = getIntersections(res_poly, wrk_poly);\n\n    // sort intersection points\n    sortIntersections(intersections);\n\n    // split by intersection points\n    splitByIntersections(res_poly, intersections.int_points1_sorted);\n    splitByIntersections(wrk_poly, intersections.int_points2_sorted);\n\n    // filter duplicated intersection points\n    filterDuplicatedIntersections(intersections);\n\n    // calculate inclusion and remove not relevant edges\n    filterNotRelevantEdges(res_poly, wrk_poly, intersections, op);\n\n    if (restore) {\n        swapLinksAndRestore(res_poly, wrk_poly, intersections, op);\n    }\n\n    return [res_poly, wrk_poly];\n}\n\nfunction getIntersections(polygon1, polygon2)\n{\n    let intersections = {\n        int_points1: [],\n        int_points2: []\n    };\n\n    // calculate intersections\n    for (let edge1 of polygon1.edges) {\n\n        // request edges of polygon2 in the box of edge1\n        let resp = polygon2.edges.search(edge1.box);\n\n        // for each edge2 in response\n        for (let edge2 of resp) {\n\n            // calculate intersections between edge1 and edge2\n            let ip = edge1.shape.intersect(edge2.shape);\n\n            // for each intersection point\n            for (let pt of ip) {\n                addToIntPoints(edge1, pt, intersections.int_points1);\n                addToIntPoints(edge2, pt, intersections.int_points2);\n            }\n        }\n    }\n    return intersections;\n}\n\nfunction addToIntPoints(edge, pt, int_points)\n{\n    let id = int_points.length;\n    let shapes = edge.shape.split(pt);\n\n    // if (shapes.length < 2) return;\n    if (shapes.length === 0) return;     // Point does not belong to edge ?\n\n    let len = 0;\n    if (shapes[0] === null) {   // point incident to edge start vertex\n        len = 0;\n    }\n    else if (shapes[1] === null) {   // point incident to edge end vertex\n        len = edge.shape.length;\n    }\n    else {                             // Edge was split into to edges\n        len = shapes[0].length;\n    }\n\n    let is_vertex = NOT_VERTEX;\n    if (EQ(len, 0)) {\n        is_vertex |= START_VERTEX;\n    }\n    if (EQ(len, edge.shape.length)) {\n        is_vertex |= END_VERTEX;\n    }\n    // Fix intersection point which is end point of the last edge\n    let arc_length = (is_vertex & END_VERTEX) && edge.next.arc_length === 0 ? 0 : edge.arc_length + len;\n\n    int_points.push({\n        id: id,\n        pt: pt,\n        arc_length: arc_length,\n        edge_before: edge,\n        edge_after: undefined,\n        face: edge.face,\n        is_vertex: is_vertex\n    });\n}\n\nfunction sortIntersections(intersections)\n{\n    // if (intersections.int_points1.length === 0) return;\n\n    // augment intersections with new sorted arrays\n    // intersections.int_points1_sorted = intersections.int_points1.slice().sort(compareFn);\n    // intersections.int_points2_sorted = intersections.int_points2.slice().sort(compareFn);\n    intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\n    intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\n}\n\nfunction getSortedArray(int_points)\n{\n    let faceMap = new Map;\n    let id = 0;\n    // Create integer id's for faces\n    for (let ip of int_points) {\n        if (!faceMap.has(ip.face)) {\n            faceMap.set(ip.face, id);\n            id++;\n        }\n    }\n    // Augment intersection points with face id's\n    for (let ip of int_points) {\n        ip.faceId = faceMap.get(ip.face);\n    }\n    // Clone and sort\n    let int_points_sorted = int_points.slice().sort(compareFn);\n    return int_points_sorted;\n}\n\nfunction compareFn(ip1, ip2)\n{\n    // compare face id's\n    if (ip1.faceId < ip2.faceId) {\n        return -1;\n    }\n    if (ip1.faceId > ip2.faceId) {\n        return 1;\n    }\n    // same face - compare arc_length\n    if (ip1.arc_length < ip2.arc_length) {\n        return -1;\n    }\n    if (ip1.arc_length > ip2.arc_length) {\n        return 1;\n    }\n    return 0;\n}\n\nfunction splitByIntersections(polygon, int_points)\n{\n    if (!int_points) return;\n    for (let int_point of int_points) {\n        let edge = int_point.edge_before;\n\n        // recalculate vertex flag: it may be changed after previous split\n        int_point.is_vertex = NOT_VERTEX;\n        if (edge.shape.start.equalTo(int_point.pt)) {\n            int_point.is_vertex |= START_VERTEX;\n        }\n        if (edge.shape.end.equalTo(int_point.pt)) {\n            int_point.is_vertex |= END_VERTEX;\n        }\n\n        if (int_point.is_vertex & START_VERTEX) {  // nothing to split\n            int_point.edge_before = edge.prev;\n            int_point.is_vertex = END_VERTEX;\n            continue;\n        }\n        if (int_point.is_vertex & END_VERTEX) {    // nothing to split\n            continue;\n        }\n\n        let newEdge = polygon.addVertex(int_point.pt, edge);\n        int_point.edge_before = newEdge;\n    }\n\n    for (let int_point of int_points) {\n        int_point.edge_after = int_point.edge_before.next;\n    }\n}\n\nfunction filterDuplicatedIntersections(intersections)\n{\n    if (intersections.int_points1.length < 2) return;\n\n    let do_squeeze = false;\n\n    let int_point_ref1;\n    let int_point_ref2;\n    let int_point_cur1;\n    let int_point_cur2;\n    for (let i = 0; i < intersections.int_points1_sorted.length; i++) {\n\n        if (intersections.int_points1_sorted[i].id === -1)\n            continue;\n\n        int_point_ref1 = intersections.int_points1_sorted[i];\n        int_point_ref2 = intersections.int_points2[int_point_ref1.id];\n\n        for (let j=i+1; j < intersections.int_points1_sorted.length; j++) {\n            int_point_cur1 = intersections.int_points1_sorted[j];\n            if (!EQ(int_point_cur1.arc_length, int_point_ref1.arc_length)) {\n                break;\n            }\n            if (int_point_cur1.id === -1)\n                continue;\n            int_point_cur2 = intersections.int_points2[int_point_cur1.id];\n            if (int_point_cur2.id === -1)\n                continue;\n            if (int_point_cur1.edge_before === int_point_ref1.edge_before &&\n                int_point_cur1.edge_after === int_point_ref1.edge_after &&\n                int_point_cur2.edge_before === int_point_ref2.edge_before &&\n                int_point_cur2.edge_after === int_point_ref2.edge_after) {\n                int_point_cur1.id = -1;\n                /* to be deleted */\n                int_point_cur2.id = -1;\n                /* to be deleted */\n                do_squeeze = true;\n            }\n        }\n    }\n\n    int_point_ref2 = intersections.int_points2_sorted[0];\n    int_point_ref1 = intersections.int_points1[int_point_ref2.id];\n    for (let i = 1; i < intersections.int_points2_sorted.length; i++) {\n        let int_point_cur2 = intersections.int_points2_sorted[i];\n\n        if (int_point_cur2.id == -1) continue;\n        /* already deleted */\n\n        if (int_point_ref2.id == -1 || /* can't be reference if already deleted */\n            !(EQ(int_point_cur2.arc_length, int_point_ref2.arc_length))) {\n            int_point_ref2 = int_point_cur2;\n            int_point_ref1 = intersections.int_points1[int_point_ref2.id];\n            continue;\n        }\n\n        let int_point_cur1 = intersections.int_points1[int_point_cur2.id];\n        if (int_point_cur1.edge_before === int_point_ref1.edge_before &&\n            int_point_cur1.edge_after === int_point_ref1.edge_after &&\n            int_point_cur2.edge_before === int_point_ref2.edge_before &&\n            int_point_cur2.edge_after === int_point_ref2.edge_after) {\n            int_point_cur1.id = -1;\n            /* to be deleted */\n            int_point_cur2.id = -1;\n            /* to be deleted */\n            do_squeeze = true;\n        }\n    }\n\n    if (do_squeeze) {\n        intersections.int_points1 = intersections.int_points1.filter((int_point) => int_point.id >= 0);\n        intersections.int_points2 = intersections.int_points2.filter((int_point) => int_point.id >= 0);\n\n        // update id's\n        intersections.int_points1.forEach((int_point, index) => int_point.id = index);\n        intersections.int_points2.forEach((int_point, index) => int_point.id = index);\n\n        // re-create sorted\n        intersections.int_points1_sorted = [];\n        intersections.int_points2_sorted = [];\n        sortIntersections(intersections);\n    }\n}\n\nfunction getNotIntersectedFaces(poly, int_points)\n{\n    let notIntersected = [];\n    for (let face of poly.faces) {\n        if (!int_points.find((ip) => ip.face === face)) {\n            notIntersected.push(face);\n        }\n    }\n    return notIntersected;\n}\n\nfunction calcInclusionForNotIntersectedFaces(notIntersectedFaces, poly2)\n{\n    for (let face of notIntersectedFaces) {\n        face.first.bv = face.first.bvStart = face.first.bvEnd = undefined;\n        face.first.setInclusion(poly2);\n    }\n}\n\nfunction initializeInclusionFlags(int_points)\n{\n    for (let int_point of int_points) {\n        int_point.edge_before.bvStart = undefined;\n        int_point.edge_before.bvEnd = undefined;\n        int_point.edge_before.bv = undefined;\n        int_point.edge_before.overlap = undefined;\n\n        int_point.edge_after.bvStart = undefined;\n        int_point.edge_after.bvEnd = undefined;\n        int_point.edge_after.bv = undefined;\n        int_point.edge_after.overlap = undefined;\n    }\n\n    for (let int_point of int_points) {\n        int_point.edge_before.bvEnd = BOUNDARY$1;\n        int_point.edge_after.bvStart = BOUNDARY$1;\n    }\n}\n\nfunction calculateInclusionFlags(int_points, polygon)\n{\n    for (let int_point of int_points) {\n        int_point.edge_before.setInclusion(polygon);\n        int_point.edge_after.setInclusion(polygon);\n    }\n}\n\nfunction fixBoundaryConflicts(poly1, poly2, int_points1, int_points1_sorted, int_points2, intersections )\n{\n    let cur_face;\n    let first_int_point_in_face_id;\n    let next_int_point1;\n    let num_int_points = int_points1_sorted.length;\n    let iterate_more = false;\n\n    for (let i = 0; i < num_int_points; i++) {\n        let cur_int_point1 = int_points1_sorted[i];\n\n        // Find boundary chain in the polygon1\n        if (cur_int_point1.face !== cur_face) {                               // next chain started\n            first_int_point_in_face_id = i; // cur_int_point1;\n            cur_face = cur_int_point1.face;\n        }\n\n        // Skip duplicated points with same <x,y> in \"cur_int_point1\" pool\n        let int_points_cur_pool_start = i;\n        let int_points_cur_pool_num = intPointsPoolCount(int_points1_sorted, i, cur_face);\n        let next_int_point_id;\n        if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points &&\n            int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) {\n            next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;\n        } else {                                         // get first point from the same face\n            next_int_point_id = first_int_point_in_face_id;\n        }\n\n        // From all points with same ,x,y. in 'next_int_point1' pool choose one that\n        // has same face both in res_poly and in wrk_poly\n        let int_points_next_pool_num = intPointsPoolCount(int_points1_sorted, next_int_point_id, cur_face);\n        next_int_point1 = null;\n        for (let j=next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++) {\n            let next_int_point1_tmp = int_points1_sorted[j];\n            if (next_int_point1_tmp.face === cur_face &&\n                int_points2[next_int_point1_tmp.id].face === int_points2[cur_int_point1.id].face) {\n                next_int_point1 = next_int_point1_tmp;\n                break;\n            }\n        }\n        if (next_int_point1 === null)\n            continue;\n\n        let edge_from1 = cur_int_point1.edge_after;\n        let edge_to1 = next_int_point1.edge_before;\n\n        // Case #1. One of the ends is not boundary - probably tiny edge wrongly marked as boundary\n        if (edge_from1.bv === BOUNDARY$1 && edge_to1.bv != BOUNDARY$1) {\n            edge_from1.bv = edge_to1.bv;\n            continue;\n        }\n\n        if (edge_from1.bv != BOUNDARY$1 && edge_to1.bv === BOUNDARY$1) {\n            edge_to1.bv = edge_from1.bv;\n            continue;\n        }\n\n        // Set up all boundary values for middle edges. Need for cases 2 and 3\n        if ( (edge_from1.bv === BOUNDARY$1 && edge_to1.bv === BOUNDARY$1 && edge_from1 != edge_to1) ||\n        (edge_from1.bv === INSIDE$1 && edge_to1.bv === OUTSIDE$1  || edge_from1.bv === OUTSIDE$1 && edge_to1.bv === INSIDE$1 ) ) {\n            let edge_tmp = edge_from1.next;\n            while (edge_tmp != edge_to1) {\n                edge_tmp.bvStart = undefined;\n                edge_tmp.bvEnd = undefined;\n                edge_tmp.bv = undefined;\n                edge_tmp.setInclusion(poly2);\n                edge_tmp = edge_tmp.next;\n            }\n        }\n\n        // Case #2. Both of the ends boundary. Check all the edges in the middle\n        // If some edges in the middle are not boundary then update bv of 'from' and 'to' edges\n        if (edge_from1.bv === BOUNDARY$1 && edge_to1.bv === BOUNDARY$1 && edge_from1 != edge_to1) {\n            let edge_tmp = edge_from1.next;\n            let new_bv;\n            while (edge_tmp != edge_to1) {\n                if (edge_tmp.bv != BOUNDARY$1) {\n                    if (new_bv === undefined) {        // first not boundary edge between from and to\n                        new_bv = edge_tmp.bv;\n                    }\n                    else {                            // another not boundary edge between from and to\n                        if (edge_tmp.bv != new_bv) {  // and it has different bv - can't resolve conflict\n                            throw Flatten.Errors.UNRESOLVED_BOUNDARY_CONFLICT;\n                        }\n                    }\n                }\n                edge_tmp = edge_tmp.next;\n            }\n\n            if (new_bv != undefined) {\n                edge_from1.bv = new_bv;\n                edge_to1.bv = new_bv;\n            }\n            continue;         // all middle edges are boundary, proceed with this\n        }\n\n        // Case 3. One of the ends is inner, another is outer\n        if (edge_from1.bv === INSIDE$1 && edge_to1.bv === OUTSIDE$1  || edge_from1.bv === OUTSIDE$1 && edge_to1.bv === INSIDE$1 ) {\n            let edge_tmp = edge_from1;\n            // Find missing intersection point\n            while (edge_tmp != edge_to1) {\n                if (edge_tmp.bvStart === edge_from1.bv && edge_tmp.bvEnd === edge_to1.bv) {\n                    let [dist, segment] = edge_tmp.shape.distanceTo(poly2);\n                    if (dist < 10*Flatten.DP_TOL) {  // it should be very close\n                        // let pt = edge_tmp.end;\n                        // add to the list of intersections of poly1\n                        addToIntPoints(edge_tmp, segment.ps, int_points1);\n\n                        // split edge_tmp in poly1 if need\n                        let int_point1 = int_points1[int_points1.length-1];\n                        if (int_point1.is_vertex & START_VERTEX) {        // nothing to split\n                            int_point1.edge_after = edge_tmp;\n                            int_point1.edge_before = edge_tmp.prev;\n                            edge_tmp.bvStart = BOUNDARY$1;\n                            edge_tmp.bv = undefined;\n                            edge_tmp.setInclusion(poly2);\n                        }\n                        else if (int_point1.is_vertex & END_VERTEX) {    // nothing to split\n                            int_point1.edge_after = edge_tmp.next;\n                            edge_tmp.bvEnd = BOUNDARY$1;\n                            edge_tmp.bv = undefined;\n                            edge_tmp.setInclusion(poly2);\n                        }\n                        else {        // split edge here\n                            let newEdge1 = poly2.addVertex(int_point1.pt, edge_tmp);\n                            int_point1.edge_before = newEdge1;\n                            int_point1.edge_after = newEdge1.next;\n\n                            newEdge1.setInclusion(poly2);\n\n                            newEdge1.next.bvStart = BOUNDARY$1;\n                            newEdge1.next.bvEnd = undefined;\n                            newEdge1.next.bv = undefined;\n                            newEdge1.next.setInclusion(poly2);\n                        }\n\n                        // add to the list of intersections of poly2\n                        let edge2 = poly2.findEdgeByPoint(segment.pe);\n                        addToIntPoints(edge2, segment.pe, int_points2);\n                        // split edge2 in poly2 if need\n                        let int_point2 = int_points2[int_points2.length-1];\n                        if (int_point2.is_vertex & START_VERTEX) {        // nothing to split\n                            int_point2.edge_after = edge2;\n                            int_point2.edge_before = edge2.prev;\n                        }\n                        else if (int_point2.is_vertex & END_VERTEX) {    // nothing to split\n                            int_point2.edge_after = edge2.next;\n                        }\n                        else {        // split edge here\n                            // first locate int_points that may refer to edge2 as edge.after\n                            // let int_point2_edge_before = int_points2.find( int_point => int_point.edge_before === edge2)\n                            let int_point2_edge_after = int_points2.find( int_point => int_point.edge_after === edge2 );\n\n                            let newEdge2 = poly2.addVertex(int_point2.pt, edge2);\n                            int_point2.edge_before = newEdge2;\n                            int_point2.edge_after = newEdge2.next;\n\n                            if (int_point2_edge_after)\n                                int_point2_edge_after.edge_after = newEdge2;\n\n                            newEdge2.bvStart = undefined;\n                            newEdge2.bvEnd = BOUNDARY$1;\n                            newEdge2.bv = undefined;\n                            newEdge2.setInclusion(poly1);\n\n                            newEdge2.next.bvStart = BOUNDARY$1;\n                            newEdge2.next.bvEnd = undefined;\n                            newEdge2.next.bv = undefined;\n                            newEdge2.next.setInclusion(poly1);\n                        }\n\n                        sortIntersections(intersections);\n\n                        iterate_more = true;\n                        break;\n                    }\n                }\n                edge_tmp = edge_tmp.next;\n            }\n\n            // we changed intersections inside loop, have to exit and repair again\n            if (iterate_more)\n                break;\n\n            throw Flatten.Errors.UNRESOLVED_BOUNDARY_CONFLICT;\n        }\n    }\n\n    return iterate_more;\n}\n\nfunction setOverlappingFlags(intersections)\n{\n    let cur_face = undefined;\n    let first_int_point_in_face_id = undefined;\n    let next_int_point1 = undefined;\n    let num_int_points = intersections.int_points1.length;\n\n    for (let i = 0; i < num_int_points; i++) {\n        let cur_int_point1 = intersections.int_points1_sorted[i];\n\n        // Find boundary chain in the polygon1\n        if (cur_int_point1.face !== cur_face) {                               // next chain started\n            first_int_point_in_face_id = i; // cur_int_point1;\n            cur_face = cur_int_point1.face;\n        }\n\n        // Skip duplicated points with same <x,y> in \"cur_int_point1\" pool\n        let int_points_cur_pool_start = i;\n        let int_points_cur_pool_num = intPointsPoolCount(intersections.int_points1_sorted, i, cur_face);\n        let next_int_point_id;\n        if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points &&\n            intersections.int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) {\n            next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;\n        } else {                                         // get first point from the same face\n            next_int_point_id = first_int_point_in_face_id;\n        }\n\n        // From all points with same ,x,y. in 'next_int_point1' pool choose one that\n        // has same face both in res_poly and in wrk_poly\n        let int_points_next_pool_num = intPointsPoolCount(intersections.int_points1_sorted, next_int_point_id, cur_face);\n        next_int_point1 = null;\n        for (let j=next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++) {\n            let next_int_point1_tmp = intersections.int_points1_sorted[j];\n            if (next_int_point1_tmp.face === cur_face &&\n                intersections.int_points2[next_int_point1_tmp.id].face === intersections.int_points2[cur_int_point1.id].face) {\n                next_int_point1 = next_int_point1_tmp;\n                break;\n            }\n        }\n        if (next_int_point1 === null)\n            continue;\n\n        let edge_from1 = cur_int_point1.edge_after;\n        let edge_to1 = next_int_point1.edge_before;\n\n        if (!(edge_from1.bv === BOUNDARY$1 && edge_to1.bv === BOUNDARY$1))      // not a boundary chain - skip\n            continue;\n\n        if (edge_from1 !== edge_to1)                    //  one edge chain    TODO: support complex case\n            continue;\n\n        /* Find boundary chain in polygon2 between same intersection points */\n        let cur_int_point2 = intersections.int_points2[cur_int_point1.id];\n        let next_int_point2 = intersections.int_points2[next_int_point1.id];\n\n        let edge_from2 = cur_int_point2.edge_after;\n        let edge_to2 = next_int_point2.edge_before;\n\n        /* if [edge_from2..edge_to2] is not a boundary chain, invert it */\n        /* check also that chain consist of one or two edges */\n        if (!(edge_from2.bv === BOUNDARY$1 && edge_to2.bv === BOUNDARY$1 && edge_from2 === edge_to2)) {\n            cur_int_point2 = intersections.int_points2[next_int_point1.id];\n            next_int_point2 = intersections.int_points2[cur_int_point1.id];\n\n            edge_from2 = cur_int_point2.edge_after;\n            edge_to2 = next_int_point2.edge_before;\n        }\n\n        if (!(edge_from2.bv === BOUNDARY$1 && edge_to2.bv === BOUNDARY$1 && edge_from2 === edge_to2))\n            continue;                           // not an overlapping chain - skip   TODO: fix boundary conflict\n\n        // Set overlapping flag - one-to-one case\n        edge_from1.setOverlap(edge_from2);\n    }\n}\n\nfunction removeNotRelevantChains(polygon, op, int_points, is_res_polygon)\n{\n    if (!int_points) return;\n    let cur_face = undefined;\n    let first_int_point_in_face_num = undefined;\n    let int_point_current;\n    let int_point_next;\n\n    for (let i = 0; i < int_points.length; i++) {\n        int_point_current = int_points[i];\n\n        if (int_point_current.face !== cur_face) {   // next face started\n            first_int_point_in_face_num = i;\n            cur_face = int_point_current.face;\n        }\n\n        if (cur_face.isEmpty())                // ??\n            continue;\n\n        // Get next int point from the same face that current\n\n        // Count how many duplicated points with same <x,y> in \"points from\" pool ?\n        let int_points_from_pull_start = i;\n        let int_points_from_pull_num = intPointsPoolCount(int_points, i, cur_face);\n        let next_int_point_num;\n        if (int_points_from_pull_start + int_points_from_pull_num < int_points.length &&\n            int_points[int_points_from_pull_start + int_points_from_pull_num].face === int_point_current.face) {\n            next_int_point_num = int_points_from_pull_start + int_points_from_pull_num;\n        } else {                                         // get first point from the same face\n            next_int_point_num = first_int_point_in_face_num;\n        }\n        int_point_next = int_points[next_int_point_num];\n\n        /* Count how many duplicated points with same <x,y> in \"points to\" pull ? */\n        let int_points_to_pull_start = next_int_point_num;\n        let int_points_to_pull_num = intPointsPoolCount(int_points, int_points_to_pull_start, cur_face);\n\n\n        let edge_from = int_point_current.edge_after;\n        let edge_to = int_point_next.edge_before;\n\n        if ((edge_from.bv === INSIDE$1 && edge_to.bv === INSIDE$1 && op === BOOLEAN_UNION) ||\n            (edge_from.bv === OUTSIDE$1 && edge_to.bv === OUTSIDE$1 && op === BOOLEAN_INTERSECT) ||\n            ((edge_from.bv === OUTSIDE$1 || edge_to.bv === OUTSIDE$1) && op === BOOLEAN_SUBTRACT && !is_res_polygon) ||\n            ((edge_from.bv === INSIDE$1 || edge_to.bv === INSIDE$1) && op === BOOLEAN_SUBTRACT && is_res_polygon) ||\n            (edge_from.bv === BOUNDARY$1 && edge_to.bv === BOUNDARY$1 && (edge_from.overlap & OVERLAP_SAME$1) && is_res_polygon) ||\n            (edge_from.bv === BOUNDARY$1 && edge_to.bv === BOUNDARY$1 && (edge_from.overlap & OVERLAP_OPPOSITE$1))) {\n\n            polygon.removeChain(cur_face, edge_from, edge_to);\n\n            /* update all points in \"points from\" pull */\n            for (let k = int_points_from_pull_start; k < int_points_from_pull_start + int_points_from_pull_num; k++) {\n                int_points[k].edge_after = undefined;\n            }\n\n            /* update all points in \"points to\" pull */\n            for (let k = int_points_to_pull_start; k < int_points_to_pull_start + int_points_to_pull_num; k++) {\n                int_points[k].edge_before = undefined;\n            }\n        }\n\n        /* skip to the last point in \"points from\" group */\n        i += int_points_from_pull_num - 1;\n    }\n}\nfunction intPointsPoolCount(int_points, cur_int_point_num, cur_face)\n{\n    let int_point_current;\n    let int_point_next;\n\n    let int_points_pool_num = 1;\n\n    if (int_points.length == 1) return 1;\n\n    int_point_current = int_points[cur_int_point_num];\n\n    for (let i = cur_int_point_num + 1; i < int_points.length; i++) {\n        if (int_point_current.face != cur_face) {      /* next face started */\n            break;\n        }\n\n        int_point_next = int_points[i];\n\n        if (!(int_point_next.pt.equalTo(int_point_current.pt) &&\n            int_point_next.edge_before === int_point_current.edge_before &&\n            int_point_next.edge_after === int_point_current.edge_after)) {\n            break;         /* next point is different - break and exit */\n        }\n\n        int_points_pool_num++;     /* duplicated intersection point - increase counter */\n    }\n    return int_points_pool_num;\n}\n\nfunction copyWrkToRes(res_polygon, wrk_polygon, op, int_points)\n{\n    for (let face of wrk_polygon.faces) {\n        for (let edge of face) {\n            res_polygon.edges.add(edge);\n        }\n        // If union - add face from wrk_polygon that is not intersected with res_polygon\n        if ( /*(op === BOOLEAN_UNION || op == BOOLEAN_SUBTRACT) &&*/\n            int_points.find((ip) => (ip.face === face)) === undefined) {\n            res_polygon.addFace(face.first, face.last);\n        }\n    }\n}\n\nfunction swapLinks(res_polygon, wrk_polygon, intersections)\n{\n    if (intersections.int_points1.length === 0) return;\n\n    for (let i = 0; i < intersections.int_points1.length; i++) {\n        let int_point1 = intersections.int_points1[i];\n        let int_point2 = intersections.int_points2[i];\n\n        // Simple case - find continuation on the other polygon\n\n        // Process edge from res_polygon\n        if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {    // swap need\n            if (int_point2.edge_before === undefined && int_point2.edge_after !== undefined) {  // simple case\n                // Connect edges\n                int_point1.edge_before.next = int_point2.edge_after;\n                int_point2.edge_after.prev = int_point1.edge_before;\n\n                // Fill in missed links in intersection points\n                int_point1.edge_after = int_point2.edge_after;\n                int_point2.edge_before = int_point1.edge_before;\n            }\n        }\n        // Process edge from wrk_polygon\n        if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {    // swap need\n            if (int_point1.edge_before === undefined && int_point1.edge_after !== undefined) {  // simple case\n                // Connect edges\n                int_point2.edge_before.next = int_point1.edge_after;\n                int_point1.edge_after.prev = int_point2.edge_before;\n\n                // Complete missed links\n                int_point2.edge_after = int_point1.edge_after;\n                int_point1.edge_before = int_point2.edge_before;\n            }\n        }\n\n        // Continuation not found - complex case\n        // Continuation will be found on the same polygon.\n        // It happens when intersection point is actually touching point\n        // Polygon1\n        if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {    // still swap need\n            for (let int_point of intersections.int_points1_sorted) {\n                if (int_point === int_point1) continue;     // skip same\n                if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\n                    if (int_point.pt.equalTo(int_point1.pt)) {\n                        // Connect edges\n                        int_point1.edge_before.next = int_point.edge_after;\n                        int_point.edge_after.prev = int_point1.edge_before;\n\n                        // Complete missed links\n                        int_point1.edge_after = int_point.edge_after;\n                        int_point.edge_before = int_point1.edge_before;\n                    }\n                }\n            }\n        }\n        // Polygon2\n        if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {    // still swap need\n            for (let int_point of intersections.int_points2_sorted) {\n                if (int_point === int_point2) continue;     // skip same\n                if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\n                    if (int_point.pt.equalTo(int_point2.pt)) {\n                        // Connect edges\n                        int_point2.edge_before.next = int_point.edge_after;\n                        int_point.edge_after.prev = int_point2.edge_before;\n\n                        // Complete missed links\n                        int_point2.edge_after = int_point.edge_after;\n                        int_point.edge_before = int_point2.edge_before;\n                    }\n                }\n            }\n        }\n    }\n    // Sanity check that no dead ends left\n}\n\nfunction removeOldFaces(polygon, int_points)\n{\n    for (let int_point of int_points) {\n        polygon.faces.delete(int_point.face);\n        int_point.face = undefined;\n        if (int_point.edge_before)\n            int_point.edge_before.face = undefined;\n        if (int_point.edge_after)\n            int_point.edge_after.face = undefined;\n    }\n}\n\nfunction restoreFaces(polygon, int_points, other_int_points)\n{\n    // For each intersection point - create new face\n    for (let int_point of int_points) {\n        if (int_point.edge_before === undefined || int_point.edge_after === undefined)  // completely deleted\n            continue;\n        if (int_point.face)            // already restored\n            continue;\n\n        if (int_point.edge_after.face || int_point.edge_before.face)        // Face already created. Possible case in duplicated intersection points\n            continue;\n\n        let first = int_point.edge_after;      // face start\n        let last = int_point.edge_before;      // face end;\n\n        LinkedList.testInfiniteLoop(first);    // check and throw error if infinite loop found\n\n        let face = polygon.addFace(first, last);\n\n        // Mark intersection points from the newly create face\n        // to avoid multiple creation of the same face\n        // Face was assigned to each edge of new face in addFace function\n        for (let int_point_tmp of int_points) {\n            if (int_point_tmp.edge_before && int_point_tmp.edge_after &&\n                int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\n                int_point_tmp.face = face;\n            }\n        }\n        // Mark other intersection points as well\n        for (let int_point_tmp of other_int_points) {\n            if (int_point_tmp.edge_before && int_point_tmp.edge_after &&\n                int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\n                int_point_tmp.face = face;\n            }\n        }\n    }\n}\n\nfunction removeNotRelevantNotIntersectedFaces(polygon, notIntersectedFaces, op, is_res_polygon)\n{\n    for (let face of notIntersectedFaces) {\n        let rel = face.first.bv;\n        if (op === BOOLEAN_UNION && rel === INSIDE$1 ||\n            op === BOOLEAN_SUBTRACT && rel === INSIDE$1 && is_res_polygon ||\n            op === BOOLEAN_SUBTRACT && rel === OUTSIDE$1 && !is_res_polygon ||\n            op === BOOLEAN_INTERSECT && rel === OUTSIDE$1) {\n\n            polygon.deleteFace(face);\n        }\n    }\n}\n\nvar BooleanOperations = /*#__PURE__*/Object.freeze({\n    BOOLEAN_UNION: BOOLEAN_UNION,\n    BOOLEAN_INTERSECT: BOOLEAN_INTERSECT,\n    BOOLEAN_SUBTRACT: BOOLEAN_SUBTRACT,\n    unify: unify,\n    subtract: subtract,\n    intersect: intersect,\n    innerClip: innerClip,\n    outerClip: outerClip,\n    calculateIntersections: calculateIntersections,\n    addToIntPoints: addToIntPoints,\n    getSortedArray: getSortedArray,\n    splitByIntersections: splitByIntersections,\n    filterDuplicatedIntersections: filterDuplicatedIntersections,\n    removeNotRelevantChains: removeNotRelevantChains,\n    removeOldFaces: removeOldFaces,\n    restoreFaces: restoreFaces\n});\n\n/*\n    Dimensionally extended 9-intersected model\n    See https://en.wikipedia.org/wiki/DE-9IM for more details\n */\n// const DISJOINT = RegExp('FF.FF....');\nconst EQUAL = RegExp('T.F..FFF.|T.F...F..');\nconst INTERSECT = RegExp('T........|.T.......|...T.....|....T....');\nconst TOUCH = RegExp('FT.......|F..T.....|F...T....');\nconst INSIDE$2 = RegExp('T.F..F...');\nconst COVERED = RegExp('T.F..F...|.TF..F...|..FT.F...|..F.TF...');\n\nclass DE9IM {\n    /**\n     * Create new instance of DE9IM matrix\n     */\n    constructor() {\n        /**\n         * Array representing 3x3 intersection matrix\n         * @type {Shape[]}\n         */\n        this.m = new Array(9).fill(undefined);\n    }\n\n    /**\n     * Get Interior To Interior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get I2I() {\n        return this.m[0];\n    }\n\n    /**\n     * Set Interior To Interior intersection\n     * @param geom\n     */\n    set I2I(geom) {\n        this.m[0] = geom;\n    }\n\n    /**\n     * Get Interior To Boundary intersection\n     * @returns {Shape[] | undefined}\n     */\n    get I2B() {\n        return this.m[1];\n    }\n\n    /**\n     * Set Interior to Boundary intersection\n     * @param geomc\n     */\n    set I2B(geom) {\n        this.m[1] = geom;\n    }\n\n    /**\n     * Get Interior To Exterior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get I2E() {\n        return this.m[2];\n    }\n\n    /**\n     * Set Interior to Exterior intersection\n     * @param geom\n     */\n    set I2E(geom) {\n        this.m[2] = geom;\n    }\n\n    /**\n     * Get Boundary To Interior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get B2I() {\n        return this.m[3];\n    }\n\n    /**\n     * Set Boundary to Interior intersection\n     * @param geom\n     */\n    set B2I(geom) {\n        this.m[3] = geom;\n    }\n\n    /**\n     * Get Boundary To Boundary intersection\n     * @returns {Shape[] | undefined}\n     */\n    get B2B() {\n        return this.m[4];\n    }\n\n    /**\n     * Set Boundary to Boundary intersection\n     * @param geom\n     */\n    set B2B(geom) {\n        this.m[4] = geom;\n    }\n\n    /**\n     * Get Boundary To Exterior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get B2E() {\n        return this.m[5];\n    }\n\n    /**\n     * Set Boundary to Exterior intersection\n     * @param geom\n     */\n    set B2E(geom) {\n        this.m[5] = geom;\n    }\n\n    /**\n     * Get Exterior To Interior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get E2I() {\n        return this.m[6];\n    }\n\n    /**\n     * Set Exterior to Interior intersection\n     * @param geom\n     */\n    set E2I(geom) {\n        this.m[6] = geom;\n    }\n\n    /**\n     * Get Exterior To Boundary intersection\n     * @returns {Shape[] | undefined}\n     */\n    get E2B() {\n        return this.m[7];\n    }\n\n    /**\n     * Set Exterior to Boundary intersection\n     * @param geom\n     */\n    set E2B(geom) {\n        this.m[7] = geom;\n    }\n\n    /**\n     * Get Exterior to Exterior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get E2E() {\n        return this.m[8];\n    }\n\n    /**\n     * Set Exterior to Exterior intersection\n     * @param geom\n     */\n    set E2E(geom) {\n        this.m[8] = geom;\n    }\n\n    /**\n     * Return de9im matrix as string where<br/>\n     * - intersection is 'T'<br/>\n     * - not intersected is 'F'<br/>\n     * - not relevant is '*'<br/>\n     * For example, string 'FF**FF****' means 'DISJOINT'\n     * @returns {string}\n     */\n    toString() {\n        return this.m.map( e => {\n            if (e instanceof Array && e.length > 0) {\n                return 'T'\n            }\n            else if (e instanceof Array && e.length === 0) {\n                return 'F'\n            }\n            else {\n                return '*'\n            }\n        }).join(\"\")\n    }\n\n    equal() {\n        return EQUAL.test(this.toString());\n    }\n\n    intersect() {\n        return INTERSECT.test(this.toString());\n    }\n\n    touch() {\n        return TOUCH.test(this.toString());\n    }\n\n    inside() {\n        return INSIDE$2.test(this.toString());\n    }\n\n    covered() {\n        return COVERED.test(this.toString());\n    }\n}\n\n/**\n * Intersection\n *\n * */\n\nfunction intersectLine2Line(line1, line2) {\n    let ip = [];\n\n    let [A1, B1, C1] = line1.standard;\n    let [A2, B2, C2] = line2.standard;\n\n    /* Cramer's rule */\n    let det = A1 * B2 - B1 * A2;\n    let detX = C1 * B2 - B1 * C2;\n    let detY = A1 * C2 - C1 * A2;\n\n    if (!Flatten.Utils.EQ_0(det)) {\n        let x, y;\n\n        if (B1 === 0) {        // vertical line x  = C1/A1, where A1 == +1 or -1\n            x = C1/A1;\n            y = detY / det;\n        }\n        else if (B2 === 0) {   // vertical line x = C2/A2, where A2 = +1 or -1\n            x = C2/A2;\n            y = detY / det;\n        }\n        else if (A1 === 0) {   // horizontal line y = C1/B1, where B1 = +1 or -1\n            x = detX / det;\n            y = C1/B1;\n        }\n        else if (A2 === 0) {   // horizontal line y = C2/B2, where B2 = +1 or -1\n            x = detX / det;\n            y = C2/B2;\n        }\n        else {\n            x = detX / det;\n            y = detY / det;\n        }\n\n        ip.push(new Flatten.Point(x, y));\n    }\n\n    return ip;\n}\n\nfunction intersectLine2Circle(line, circle) {\n    let ip = [];\n    let prj = circle.pc.projectionOn(line);            // projection of circle center on line\n    let dist = circle.pc.distanceTo(prj)[0];           // distance from circle center to projection\n\n    if (Flatten.Utils.EQ(dist, circle.r)) {            // line tangent to circle - return single intersection point\n        ip.push(prj);\n    } else if (Flatten.Utils.LT(dist, circle.r)) {       // return two intersection points\n        let delta = Math.sqrt(circle.r * circle.r - dist * dist);\n        let v_trans, pt;\n\n        v_trans = line.norm.rotate90CCW().multiply(delta);\n        pt = prj.translate(v_trans);\n        ip.push(pt);\n\n        v_trans = line.norm.rotate90CW().multiply(delta);\n        pt = prj.translate(v_trans);\n        ip.push(pt);\n    }\n    return ip;\n}\n\nfunction intersectLine2Box(line, box) {\n    let ips = [];\n    for (let seg of box.toSegments()) {\n        let ips_tmp = intersectSegment2Line(seg, line);\n        for (let pt of ips_tmp) {\n            if (!ptInIntPoints(pt, ips)) {\n                ips.push(pt);\n            }\n        }\n    }\n    return ips;\n}\n\nfunction intersectLine2Arc(line, arc) {\n    let ip = [];\n\n    if (intersectLine2Box(line, arc.box).length === 0) {\n        return ip;\n    }\n\n    let circle = new Flatten.Circle(arc.pc, arc.r);\n    let ip_tmp = intersectLine2Circle(line, circle);\n    for (let pt of ip_tmp) {\n        if (pt.on(arc)) {\n            ip.push(pt);\n        }\n    }\n\n    return ip;\n}\n\nfunction intersectSegment2Line(seg, line) {\n    let ip = [];\n\n    // Boundary cases\n    if (seg.ps.on(line)) {\n        ip.push(seg.ps);\n    }\n    // If both ends lay on line, return two intersection points\n    if (seg.pe.on(line) && !seg.isZeroLength()) {\n        ip.push(seg.pe);\n    }\n\n    if (ip.length > 0) {\n        return ip;          // done, intersection found\n    }\n\n    // If zero-length segment and nothing found, return no intersections\n    if (seg.isZeroLength()) {\n        return ip;\n    }\n\n    // Not a boundary case, check if both points are on the same side and\n    // hence there is no intersection\n    if (seg.ps.leftTo(line) && seg.pe.leftTo(line) ||\n        !seg.ps.leftTo(line) && !seg.pe.leftTo(line)) {\n        return ip;\n    }\n\n    // Calculate intersection between lines\n    let line1 = new Flatten.Line(seg.ps, seg.pe);\n    return intersectLine2Line(line1, line);\n}\n\nfunction intersectSegment2Segment(seg1, seg2) {\n    let ip = [];\n\n    // quick reject\n    if (seg1.box.not_intersect(seg2.box)) {\n        return ip;\n    }\n\n    // Special case of seg1 zero length\n    if (seg1.isZeroLength()) {\n        if (seg1.ps.on(seg2)) {\n            ip.push(seg1.ps);\n        }\n        return ip;\n    }\n\n    // Special case of seg2 zero length\n    if (seg2.isZeroLength()) {\n        if (seg2.ps.on(seg1)) {\n            ip.push(seg2.ps);\n        }\n        return ip;\n    }\n\n    // Neither seg1 nor seg2 is zero length\n    let line1 = new Flatten.Line(seg1.ps, seg1.pe);\n    let line2 = new Flatten.Line(seg2.ps, seg2.pe);\n\n    // Check overlapping between segments in case of incidence\n    // If segments touching, add one point. If overlapping, add two points\n    if (line1.incidentTo(line2)) {\n        if (seg1.ps.on(seg2)) {\n            ip.push(seg1.ps);\n        }\n        if (seg1.pe.on(seg2)) {\n            ip.push(seg1.pe);\n        }\n        if (seg2.ps.on(seg1) && !seg2.ps.equalTo(seg1.ps) && !seg2.ps.equalTo(seg1.pe)) {\n            ip.push(seg2.ps);\n        }\n        if (seg2.pe.on(seg1) && !seg2.pe.equalTo(seg1.ps) && !seg2.pe.equalTo(seg1.pe)) {\n            ip.push(seg2.pe);\n        }\n    } else {                /* not incident - parallel or intersect */\n        // Calculate intersection between lines\n        let new_ip = intersectLine2Line(line1, line2);\n        if (new_ip.length > 0 && new_ip[0].on(seg1) && new_ip[0].on(seg2)) {\n            ip.push(new_ip[0]);\n        }\n\n        // Fix missing intersection\n        // const tol = 10*Flatten.DP_TOL;\n        // if (ip.length === 0 && new_ip.length > 0 && (new_ip[0].distanceTo(seg1)[0] < tol || new_ip[0].distanceTo(seg2)[0] < tol) ) {\n        //     if (seg1.start.distanceTo(seg2)[0] < tol) {\n        //         ip.push(new_ip[0]);\n        //     }\n        //     else if (seg1.end.distanceTo(seg2)[0] < tol) {\n        //         ip.push(new_ip[0]);\n        //     }\n        //     else if (seg2.start.distanceTo(seg1)[0] < tol) {\n        //         ip.push(new_ip[0]);\n        //     }\n        //     else if (seg2.end.distanceTo(seg1)[0] < tol) {\n        //         ip.push(new_ip[0]);\n        //     }\n        // }\n    }\n\n    return ip;\n}\n\nfunction intersectSegment2Circle(segment, circle) {\n    let ips = [];\n\n    if (segment.box.not_intersect(circle.box)) {\n        return ips;\n    }\n\n    // Special case of zero length segment\n    if (segment.isZeroLength()) {\n        let [dist, shortest_segment] = segment.ps.distanceTo(circle.pc);\n        if (Flatten.Utils.EQ(dist, circle.r)) {\n            ips.push(segment.ps);\n        }\n        return ips;\n    }\n\n    // Non zero-length segment\n    let line = new Flatten.Line(segment.ps, segment.pe);\n\n    let ips_tmp = intersectLine2Circle(line, circle);\n\n    for (let ip of ips_tmp) {\n        if (ip.on(segment)) {\n            ips.push(ip);\n        }\n    }\n\n    return ips;\n}\n\nfunction intersectSegment2Arc(segment, arc) {\n    let ip = [];\n\n    if (segment.box.not_intersect(arc.box)) {\n        return ip;\n    }\n\n    // Special case of zero-length segment\n    if (segment.isZeroLength()) {\n        if (segment.ps.on(arc)) {\n            ip.push(segment.ps);\n        }\n        return ip;\n    }\n\n    // Non-zero length segment\n    let line = new Flatten.Line(segment.ps, segment.pe);\n    let circle = new Flatten.Circle(arc.pc, arc.r);\n\n    let ip_tmp = intersectLine2Circle(line, circle);\n\n    for (let pt of ip_tmp) {\n        if (pt.on(segment) && pt.on(arc)) {\n            ip.push(pt);\n        }\n    }\n    return ip;\n\n}\n\nfunction intersectSegment2Box(segment, box) {\n    let ips = [];\n    for (let seg of box.toSegments()) {\n        let ips_tmp = intersectSegment2Segment(seg, segment);\n        for (let ip of ips_tmp) {\n            ips.push(ip);\n        }\n    }\n    return ips;\n}\n\nfunction intersectCircle2Circle(circle1, circle2) {\n    let ip = [];\n\n    if (circle1.box.not_intersect(circle2.box)) {\n        return ip;\n    }\n\n    let vec = new Flatten.Vector(circle1.pc, circle2.pc);\n\n    let r1 = circle1.r;\n    let r2 = circle2.r;\n\n    // Degenerated circle\n    if (Flatten.Utils.EQ_0(r1) || Flatten.Utils.EQ_0(r2))\n        return ip;\n\n    // In case of equal circles return one leftmost point\n    if (Flatten.Utils.EQ_0(vec.x) && Flatten.Utils.EQ_0(vec.y) && Flatten.Utils.EQ(r1, r2)) {\n        ip.push(circle1.pc.translate(-r1, 0));\n        return ip;\n    }\n\n    let dist = circle1.pc.distanceTo(circle2.pc)[0];\n\n    if (Flatten.Utils.GT(dist, r1 + r2))               // circles too far, no intersections\n        return ip;\n\n    if (Flatten.Utils.LT(dist, Math.abs(r1 - r2)))     // one circle is contained within another, no intersections\n        return ip;\n\n    // Normalize vector.\n    vec.x /= dist;\n    vec.y /= dist;\n\n    let pt;\n\n    // Case of touching from outside or from inside - single intersection point\n    // TODO: check this specifically not sure if correct\n    if (Flatten.Utils.EQ(dist, r1 + r2) || Flatten.Utils.EQ(dist, Math.abs(r1 - r2))) {\n        pt = circle1.pc.translate(r1 * vec.x, r1 * vec.y);\n        ip.push(pt);\n        return ip;\n    }\n\n    // Case of two intersection points\n\n    // Distance from first center to center of common chord:\n    //   a = (r1^2 - r2^2 + d^2) / 2d\n    // Separate for better accuracy\n    let a = (r1 * r1) / (2 * dist) - (r2 * r2) / (2 * dist) + dist / 2;\n\n    let mid_pt = circle1.pc.translate(a * vec.x, a * vec.y);\n    let h = Math.sqrt(r1 * r1 - a * a);\n    // let norm;\n\n    // norm = vec.rotate90CCW().multiply(h);\n    pt = mid_pt.translate(vec.rotate90CCW().multiply(h));\n    ip.push(pt);\n\n    // norm = vec.rotate90CW();\n    pt = mid_pt.translate(vec.rotate90CW().multiply(h));\n    ip.push(pt);\n\n    return ip;\n}\n\nfunction intersectCircle2Box(circle, box) {\n    let ips = [];\n    for (let seg of box.toSegments()) {\n        let ips_tmp = intersectSegment2Circle(seg, circle);\n        for (let ip of ips_tmp) {\n            ips.push(ip);\n        }\n    }\n    return ips;\n}\n\nfunction intersectArc2Arc(arc1, arc2) {\n    var ip = [];\n\n    if (arc1.box.not_intersect(arc2.box)) {\n        return ip;\n    }\n\n    // Special case: overlapping arcs\n    // May return up to 4 intersection points\n    if (arc1.pc.equalTo(arc2.pc) && Flatten.Utils.EQ(arc1.r, arc2.r)) {\n        let pt;\n\n        pt = arc1.start;\n        if (pt.on(arc2))\n            ip.push(pt);\n\n        pt = arc1.end;\n        if (pt.on(arc2))\n            ip.push(pt);\n\n        pt = arc2.start;\n        if (pt.on(arc1)) ip.push(pt);\n\n        pt = arc2.end;\n        if (pt.on(arc1)) ip.push(pt);\n\n        return ip;\n    }\n\n    // Common case\n    let circle1 = new Flatten.Circle(arc1.pc, arc1.r);\n    let circle2 = new Flatten.Circle(arc2.pc, arc2.r);\n    let ip_tmp = circle1.intersect(circle2);\n    for (let pt of ip_tmp) {\n        if (pt.on(arc1) && pt.on(arc2)) {\n            ip.push(pt);\n        }\n    }\n    return ip;\n}\n\nfunction intersectArc2Circle(arc, circle) {\n    let ip = [];\n\n    if (arc.box.not_intersect(circle.box)) {\n        return ip;\n    }\n\n    // Case when arc center incident to circle center\n    // Return arc's end points as 2 intersection points\n    if (circle.pc.equalTo(arc.pc) && Flatten.Utils.EQ(circle.r, arc.r)) {\n        ip.push(arc.start);\n        ip.push(arc.end);\n        return ip;\n    }\n\n    // Common case\n    let circle1 = circle;\n    let circle2 = new Flatten.Circle(arc.pc, arc.r);\n    let ip_tmp = intersectCircle2Circle(circle1, circle2);\n    for (let pt of ip_tmp) {\n        if (pt.on(arc)) {\n            ip.push(pt);\n        }\n    }\n    return ip;\n}\n\nfunction intersectArc2Box(arc, box) {\n    let ips = [];\n    for (let seg of box.toSegments()) {\n        let ips_tmp = intersectSegment2Arc(seg, arc);\n        for (let ip of ips_tmp) {\n            ips.push(ip);\n        }\n    }\n    return ips;\n}\n\nfunction intersectEdge2Segment(edge, segment) {\n    return edge.isSegment() ? intersectSegment2Segment(edge.shape, segment) : intersectSegment2Arc(segment, edge.shape);\n}\n\nfunction intersectEdge2Arc(edge, arc) {\n    return edge.isSegment() ? intersectSegment2Arc(edge.shape, arc) : intersectArc2Arc(edge.shape, arc);\n}\n\nfunction intersectEdge2Line(edge, line) {\n    return edge.isSegment() ? intersectSegment2Line(edge.shape, line) : intersectLine2Arc(line, edge.shape);\n}\n\nfunction intersectEdge2Circle(edge, circle) {\n    return edge.isSegment() ? intersectSegment2Circle(edge.shape, circle) : intersectArc2Circle(edge.shape, circle);\n}\n\nfunction intersectSegment2Polygon(segment, polygon) {\n    let ip = [];\n\n    for (let edge of polygon.edges) {\n        for (let pt of intersectEdge2Segment(edge, segment)) {\n            ip.push(pt);\n        }\n    }\n\n    return ip;\n}\n\nfunction intersectArc2Polygon(arc, polygon) {\n    let ip = [];\n\n    for (let edge of polygon.edges) {\n        for (let pt of intersectEdge2Arc(edge, arc)) {\n            ip.push(pt);\n        }\n    }\n\n    return ip;\n}\n\nfunction intersectLine2Polygon(line, polygon) {\n    let ip = [];\n\n    if (polygon.isEmpty()) {\n        return ip;\n    }\n\n    for (let edge of polygon.edges) {\n        for (let pt of intersectEdge2Line(edge, line)) {\n            if (!ptInIntPoints(pt, ip)) {\n                ip.push(pt);\n            }\n        }\n    }\n\n    return line.sortPoints(ip);\n}\n\nfunction intersectCircle2Polygon(circle, polygon) {\n    let ip = [];\n\n    if (polygon.isEmpty()) {\n        return ip;\n    }\n\n    for (let edge of polygon.edges) {\n        for (let pt of intersectEdge2Circle(edge, circle)) {\n            ip.push(pt);\n        }\n    }\n\n    return ip;\n}\n\nfunction intersectEdge2Edge(edge1, edge2) {\n    const shape1 = edge1.shape;\n    const shape2 = edge2.shape;\n    return edge1.isSegment() ?\n        (edge2.isSegment() ? intersectSegment2Segment(shape1, shape2) : intersectSegment2Arc(shape1, shape2)) :\n        (edge2.isSegment() ? intersectSegment2Arc(shape2, shape1) : intersectArc2Arc(shape1, shape2));\n}\n\nfunction intersectEdge2Polygon(edge, polygon) {\n    let ip = [];\n\n    if (polygon.isEmpty() || edge.shape.box.not_intersect(polygon.box)) {\n        return ip;\n    }\n\n    let resp_edges = polygon.edges.search(edge.shape.box);\n\n    for (let resp_edge of resp_edges) {\n        for (let pt of intersectEdge2Edge(edge, resp_edge)) {\n            ip.push(pt);\n        }\n    }\n\n    return ip;\n}\n\nfunction intersectPolygon2Polygon(polygon1, polygon2) {\n    let ip = [];\n\n    if (polygon1.isEmpty() || polygon2.isEmpty()) {\n        return ip;\n    }\n\n    if (polygon1.box.not_intersect(polygon2.box)) {\n        return ip;\n    }\n\n    for (let edge1 of polygon1.edges) {\n        for (let pt of intersectEdge2Polygon(edge1, polygon2)) {\n            ip.push(pt);\n        }\n    }\n\n    return ip;\n}\n\nfunction intersectShape2Polygon(shape, polygon) {\n    if (shape instanceof Flatten.Line) {\n        return intersectLine2Polygon(shape, polygon);\n    }\n    else if (shape instanceof Flatten.Segment) {\n        return intersectSegment2Polygon(shape, polygon);\n    }\n    else if (shape instanceof Flatten.Arc) {\n        return intersectArc2Polygon(shape, polygon);\n    }\n    else {\n        return [];\n    }\n}\n\nfunction ptInIntPoints(new_pt, ip) {\n    return ip.some( pt => pt.equalTo(new_pt) )\n}\n\n/**\n * Class Multiline represent connected path of [edges]{@link Flatten.Edge}, where each edge may be\n * [segment]{@link Flatten.Segment}, [arc]{@link Flatten.Arc}, [line]{@link Flatten.Line} or [ray]{@link Flatten.Ray}\n */\nclass Multiline extends LinkedList {\n    constructor(...args) {\n        super();\n\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length == 1) {\n            if (args[0] instanceof Array) {\n                let shapes = args[0];\n                if (shapes.length == 0)\n                    return;\n\n                // TODO: more strict validation:\n                // there may be only one line\n                // only first and last may be rays\n                let validShapes = shapes.every((shape) => {\n                    return shape instanceof Flatten.Segment ||\n                        shape instanceof Flatten.Arc ||\n                        shape instanceof Flatten.Ray ||\n                        shape instanceof Flatten.Line\n                });\n\n                for (let shape of shapes) {\n                    let edge = new Flatten.Edge(shape);\n                    this.append(edge);\n                }\n            }\n        }\n    }\n\n    /**\n     * (Getter) Return array of edges\n     * @returns {Edge[]}\n     */\n    get edges() {\n        return [...this];\n    }\n\n    /**\n     * (Getter) Return bounding box of the multiline\n     * @returns {Box}\n     */\n    get box() {\n        return this.edges.reduce( (acc,edge) => acc = acc.merge(edge.box), new Flatten.Box() );\n    }\n\n    /**\n     * (Getter) Returns array of vertices\n     * @returns {Point[]}\n     */\n    get vertices() {\n        let v = this.edges.map(edge => edge.start);\n        v.push(this.last.end);\n        return v;\n    }\n\n    /**\n     * Return new cloned instance of Multiline\n     * @returns {Multiline}\n     */\n    clone() {\n        return new Multiline(this.toShapes());\n    }\n\n    /**\n     * Split edge and add new vertex, return new edge inserted\n     * @param {Point} pt - point on edge that will be added as new vertex\n     * @param {Edge} edge - edge to split\n     * @returns {Edge}\n     */\n    addVertex(pt, edge) {\n        let shapes = edge.shape.split(pt);\n        // if (shapes.length < 2) return;\n\n        if (shapes[0] === null)   // point incident to edge start vertex, return previous edge\n           return edge.prev;\n\n        if (shapes[1] === null)   // point incident to edge end vertex, return edge itself\n           return edge;\n\n        let newEdge = new Flatten.Edge(shapes[0]);\n        let edgeBefore = edge.prev;\n\n        /* Insert first split edge into linked list after edgeBefore */\n        this.insert(newEdge, edgeBefore);     // edge.face ?\n\n        // Update edge shape with second split edge keeping links\n        edge.shape = shapes[1];\n\n        return newEdge;\n    }\n\n    /**\n     * Split edges of multiline with intersection points and return mutated multiline\n     * @param {Point[]} ip - array of points to be added as new vertices\n     * @returns {Multiline}\n     */\n    split(ip) {\n        for (let pt of ip) {\n            let edge = this.findEdgeByPoint(pt);\n            this.addVertex(pt, edge);\n        }\n        return this;\n    }\n\n    /**\n     * Returns edge which contains given point\n     * @param {Point} pt\n     * @returns {Edge}\n     */\n    findEdgeByPoint(pt) {\n        let edgeFound;\n        for (let edge of this) {\n            if (edge.shape.contains(pt)) {\n                edgeFound = edge;\n                break;\n            }\n        }\n        return edgeFound;\n    }\n\n    /**\n     * Returns new multiline translated by vector vec\n     * @param {Vector} vec\n     * @returns {Multiline}\n     */\n    translate(vec) {\n        return new Multiline(this.edges.map( edge => edge.shape.translate(vec)));\n    }\n\n    /**\n     * Return new multiline rotated by given angle around given point\n     * If point omitted, rotate around origin (0,0)\n     * Positive value of angle defines rotation counter clockwise, negative - clockwise\n     * @param {number} angle - rotation angle in radians\n     * @param {Point} center - rotation center, default is (0,0)\n     * @returns {Multiline} - new rotated polygon\n     */\n    rotate(angle = 0, center = new Flatten.Point()) {\n        return new Multiline(this.edges.map( edge => edge.shape.rotate(angle, center) ));\n    }\n\n    /**\n     * Return new multiline transformed using affine transformation matrix\n     * Method does not support unbounded shapes\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Multiline} - new multiline\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        return new Multiline(this.edges.map( edge => edge.shape.transform(matrix)));\n    }\n\n    /**\n     * Transform multiline into array of shapes\n     * @returns {Shape[]}\n     */\n    toShapes() {\n        return this.edges.map(edge => edge.shape.clone())\n    }\n\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */\n    toJSON() {\n        return this.edges.map(edge => edge.toJSON());\n    }\n\n    /**\n     * Return string to draw multiline in svg\n     * @param attrs  - an object with attributes for svg path element,\n     * like \"stroke\", \"strokeWidth\", \"fill\", \"fillRule\", \"fillOpacity\"\n     * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"lightcyan\", fillRule:\"evenodd\", fillOpacity: \"1\"\n     * TODO: support semi-infinite Ray and infinite Line\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        let {stroke, strokeWidth, fill, fillRule, fillOpacity, id, className} = attrs;\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\n\n        let svgStr = `\\n<path stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} d=\"`;\n        svgStr += `\\nM${this.first.start.x},${this.first.start.y}`;\n        for (let edge of this) {\n            svgStr += edge.svg();\n        }\n        svgStr += `\" >\\n</path>`;\n\n        return svgStr;\n    }\n}\n\nFlatten.Multiline = Multiline;\n\n/**\n * Shortcut function to create multiline\n * @param args\n */\nconst multiline = (...args) => new Flatten.Multiline(...args);\nFlatten.multiline = multiline;\n\n/**\n * @module RayShoot\n */\n\n/**\n * Implements ray shooting algorithm. Returns relation between point and polygon: inside, outside or boundary\n * @param {Polgon} polygon - polygon to test\n * @param {Point} point - point to test\n * @returns {Flatten.Inside|Flatten.OUTSIDE|Flatten.Boundary}\n */\nfunction ray_shoot(polygon, point) {\n    let contains = undefined;\n\n    // 1. Quick reject\n    // if (polygon.box.not_intersect(point.box)) {\n    //     return Flatten.OUTSIDE;\n    // }\n\n    let ray = new Flatten.Ray(point);\n    let line = new Flatten.Line(ray.pt, ray.norm);\n\n    // 2. Locate relevant edges of the polygon\n    const searchBox = new Flatten.Box(\n        ray.box.xmin-Flatten.DP_TOL, ray.box.ymin-Flatten.DP_TOL,\n        ray.box.xmax, ray.box.ymax+Flatten.DP_TOL\n    );\n\n    if (polygon.box.not_intersect(searchBox)) {\n        return Flatten.OUTSIDE;\n    }\n\n    let resp_edges = polygon.edges.search(searchBox);\n\n    if (resp_edges.length == 0) {\n        return Flatten.OUTSIDE;\n    }\n\n    // 2.5 Check if boundary\n    for (let edge of resp_edges) {\n        if (edge.shape.contains(point)) {\n            return Flatten.BOUNDARY;\n        }\n    }\n\n    // 3. Calculate intersections\n    let intersections = [];\n    for (let edge of resp_edges) {\n        for (let ip of ray.intersect(edge.shape)) {\n\n            // If intersection is equal to query point then point lays on boundary\n            if (ip.equalTo(point)) {\n                return Flatten.BOUNDARY;\n            }\n\n            intersections.push({\n                pt: ip,\n                edge: edge\n            });\n        }\n    }\n\n    // 4. Sort intersection in x-ascending order\n    intersections.sort((i1, i2) => {\n        if (LT(i1.pt.x, i2.pt.x)) {\n            return -1;\n        }\n        if (GT(i1.pt.x, i2.pt.x)) {\n            return 1;\n        }\n        return 0;\n    });\n\n    // 5. Count real intersections, exclude touching\n    let counter = 0;\n\n    for (let i = 0; i < intersections.length; i++) {\n        let intersection = intersections[i];\n        if (intersection.pt.equalTo(intersection.edge.shape.start)) {\n            /* skip same point between same edges if already counted */\n            if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) &&\n                intersection.edge.prev === intersections[i - 1].edge) {\n                continue;\n            }\n            let prev_edge = intersection.edge.prev;\n            while (EQ_0(prev_edge.length)) {\n                prev_edge = prev_edge.prev;\n            }\n            let prev_tangent = prev_edge.shape.tangentInEnd();\n            let prev_point = intersection.pt.translate(prev_tangent);\n\n            let cur_tangent = intersection.edge.shape.tangentInStart();\n            let cur_point = intersection.pt.translate(cur_tangent);\n\n            let prev_on_the_left = prev_point.leftTo(line);\n            let cur_on_the_left = cur_point.leftTo(line);\n\n            if ((prev_on_the_left && !cur_on_the_left) || (!prev_on_the_left && cur_on_the_left)) {\n                counter++;\n            }\n        } else if (intersection.pt.equalTo(intersection.edge.shape.end)) {\n            /* skip same point between same edges if already counted */\n            if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) &&\n                intersection.edge.next === intersections[i - 1].edge) {\n                continue;\n            }\n            let next_edge = intersection.edge.next;\n            while (EQ_0(next_edge.length)) {\n                next_edge = next_edge.next;\n            }\n            let next_tangent = next_edge.shape.tangentInStart();\n            let next_point = intersection.pt.translate(next_tangent);\n\n            let cur_tangent = intersection.edge.shape.tangentInEnd();\n            let cur_point = intersection.pt.translate(cur_tangent);\n\n            let next_on_the_left = next_point.leftTo(line);\n            let cur_on_the_left = cur_point.leftTo(line);\n\n            if ((next_on_the_left && !cur_on_the_left) || (!next_on_the_left && cur_on_the_left)) {\n                counter++;\n            }\n        } else {        /* intersection point is not a coincident with a vertex */\n            if (intersection.edge.shape instanceof Flatten.Segment) {\n                counter++;\n            } else {\n                /* Check if ray does not touch the curve in the extremal (top or bottom) point */\n                let box = intersection.edge.shape.box;\n                if (!(EQ(intersection.pt.y, box.ymin) ||\n                    EQ(intersection.pt.y, box.ymax))) {\n                    counter++;\n                }\n            }\n        }\n    }\n\n    // 6. Odd or even?\n    contains = counter % 2 == 1 ? Flatten.INSIDE : Flatten.OUTSIDE;\n\n    return contains;\n}\n\n/*\n    Calculate relationship between two shapes and return result in the form of\n    Dimensionally Extended nine-Intersection Matrix (https://en.wikipedia.org/wiki/DE-9IM)\n */\n\n/**\n * Returns true if shapes are topologically equal:  their interiors intersect and\n * no part of the interior or boundary of one geometry intersects the exterior of the other\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction equal(shape1, shape2) {\n    return relate(shape1, shape2).equal();\n}\n\n/**\n * Returns true if shapes have at least one point in common, same as \"not disjoint\"\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction intersect$1(shape1, shape2) {\n    return relate(shape1, shape2).intersect();\n}\n\n/**\n * Returns true if shapes have at least one point in common, but their interiors do not intersect\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction touch(shape1, shape2) {\n    return relate(shape1, shape2).touch();\n}\n\n/**\n * Returns true if shapes have no points in common neither in interior nor in boundary\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction disjoint(shape1, shape2) {\n    return !intersect$1(shape1, shape2);\n}\n\n/**\n * Returns true shape1 lies in the interior of shape2\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction inside(shape1, shape2) {\n    return relate(shape1, shape2).inside();\n}\n\n/**\n * Returns true if every point in shape1 lies in the interior or on the boundary of shape2\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction covered(shape1, shape2) {\n    return  relate(shape1, shape2).covered();\n}\n\n/**\n * Returns true shape1's interior contains shape2 <br/>\n * Same as inside(shape2, shape1)\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction contain(shape1, shape2) {\n    return inside(shape2, shape1);\n}\n\n/**\n * Returns true shape1's cover shape2, same as shape2 covered by shape1\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction cover(shape1, shape2) {\n    return covered(shape2, shape1);\n}\n\n/**\n * Returns relation between two shapes as intersection 3x3 matrix, where each\n * element contains relevant intersection as array of shapes.\n * If there is no intersection, element contains empty array\n * If intersection is irrelevant it left undefined. (For example, intersection\n * between two exteriors is usually irrelevant)\n * @param shape1\n * @param shape2\n * @returns {DE9IM}\n */\nfunction relate(shape1, shape2) {\n    if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Line) {\n        return relateLine2Line(shape1,  shape2);\n    }\n    else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Circle) {\n        return relateLine2Circle(shape1, shape2);\n    }\n    else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Box) {\n        return relateLine2Box(shape1, shape2);\n    }\n    else if ( shape1 instanceof Flatten.Line  && shape2 instanceof Flatten.Polygon) {\n        return relateLine2Polygon(shape1, shape2);\n    }\n    else if ( (shape1 instanceof Flatten.Segment || shape1 instanceof Flatten.Arc)  && shape2 instanceof Flatten.Polygon) {\n        return relateShape2Polygon(shape1, shape2);\n    }\n    else if ( (shape1 instanceof Flatten.Segment || shape1 instanceof Flatten.Arc)  &&\n        (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box) ) {\n        return relateShape2Polygon(shape1, new Flatten.Polygon(shape2));\n    }\n    else if (shape1 instanceof Flatten.Polygon && shape2 instanceof Flatten.Polygon) {\n        return relatePolygon2Polygon(shape1, shape2);\n    }\n    else if ((shape1 instanceof Flatten.Circle || shape1 instanceof Flatten.Box) &&\n        (shape2 instanceof  Flatten.Circle || shape2 instanceof Flatten.Box)) {\n        return relatePolygon2Polygon(new Flatten.Polygon(shape1), new Flatten.Polygon(shape2));\n    }\n    else if ((shape1 instanceof Flatten.Circle || shape1 instanceof Flatten.Box) && shape2 instanceof Flatten.Polygon) {\n        return relatePolygon2Polygon(new Flatten.Polygon(shape1), shape2);\n    }\n    else if (shape1 instanceof Flatten.Polygon && (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box)) {\n        return relatePolygon2Polygon(shape1, new Flatten.Polygon(shape2));\n    }\n}\n\nfunction relateLine2Line(line1, line2) {\n    let denim = new DE9IM();\n    let ip = intersectLine2Line(line1, line2);\n    if (ip.length === 0) {       // parallel or equal ?\n        if (line1.contains(line2.pt) && line2.contains(line1.pt)) {\n            denim.I2I = [line1];   // equal  'T.F...F..'  - no boundary\n            denim.I2E = [];\n            denim.E2I = [];\n        }\n        else {                     // parallel - disjoint 'FFTFF*T**'\n            denim.I2I = [];\n            denim.I2E = [line1];\n            denim.E2I = [line2];\n        }\n    }\n    else {                       // intersect   'T********'\n        denim.I2I = ip;\n        denim.I2E = line1.split(ip);\n        denim.E2I = line2.split(ip);\n    }\n    return denim;\n}\n\nfunction relateLine2Circle(line,circle) {\n    let denim = new DE9IM();\n    let ip = intersectLine2Circle(line, circle);\n    if (ip.length === 0) {\n        denim.I2I = [];\n        denim.I2B = [];\n        denim.I2E = [line];\n        denim.E2I = [circle];\n    }\n    else if (ip.length === 1) {\n        denim.I2I = [];\n        denim.I2B = ip;\n        denim.I2E = line.split(ip);\n\n        denim.E2I = [circle];\n    }\n    else {       // ip.length == 2\n        let multiline = new Multiline([line]);\n        let ip_sorted = line.sortPoints(ip);\n        multiline.split(ip_sorted);\n        let splitShapes = multiline.toShapes();\n\n        denim.I2I = [splitShapes[1]];\n        denim.I2B = ip_sorted;\n        denim.I2E = [splitShapes[0], splitShapes[2]];\n\n        denim.E2I = new Flatten.Polygon([circle.toArc()]).cut(multiline);\n    }\n\n    return denim;\n}\n\nfunction relateLine2Box(line, box) {\n    let denim = new DE9IM();\n    let ip = intersectLine2Box(line, box);\n    if (ip.length === 0) {\n        denim.I2I = [];\n        denim.I2B = [];\n        denim.I2E = [line];\n\n        denim.E2I = [box];\n    }\n    else if (ip.length === 1) {\n        denim.I2I = [];\n        denim.I2B = ip;\n        denim.I2E = line.split(ip);\n\n        denim.E2I = [box];\n    }\n    else {                     // ip.length == 2\n        let multiline = new Multiline([line]);\n        let ip_sorted = line.sortPoints(ip);\n        multiline.split(ip_sorted);\n        let splitShapes = multiline.toShapes();\n\n        /* Are two intersection points on the same segment of the box boundary ? */\n        if (box.toSegments().some( segment => segment.contains(ip[0]) && segment.contains(ip[1]) )) {\n            denim.I2I = [];                         // case of touching\n            denim.I2B = [splitShapes[1]];\n            denim.I2E = [splitShapes[0], splitShapes[2]];\n\n            denim.E2I = [box];\n        }\n        else {                                       // case of intersection\n            denim.I2I = [splitShapes[1]];            // [segment(ip[0], ip[1])];\n            denim.I2B = ip_sorted;\n            denim.I2E = [splitShapes[0], splitShapes[2]];\n\n            denim.E2I = new Flatten.Polygon(box.toSegments()).cut(multiline);\n        }\n    }\n    return denim;\n}\n\nfunction relateLine2Polygon(line, polygon) {\n    let denim = new DE9IM();\n    let ip = intersectLine2Polygon(line, polygon);\n    let multiline = new Multiline([line]);\n    let ip_sorted = ip.length > 0 ? ip.slice() : line.sortPoints(ip);\n\n    multiline.split(ip_sorted);\n\n    [...multiline].forEach(edge => edge.setInclusion(polygon));\n\n    denim.I2I = [...multiline].filter(edge => edge.bv === Flatten.INSIDE).map(edge => edge.shape);\n    denim.I2B = [...multiline].slice(1).map( (edge) => edge.bv === Flatten.BOUNDARY ? edge.shape : edge.shape.start );\n    denim.I2E = [...multiline].filter(edge => edge.bv === Flatten.OUTSIDE).map(edge => edge.shape);\n\n    denim.E2I = polygon.cut(multiline);\n\n    return denim;\n}\n\nfunction relateShape2Polygon(shape, polygon) {\n    let denim = new DE9IM();\n    let ip = intersectShape2Polygon(shape, polygon);\n    let ip_sorted = ip.length > 0 ? ip.slice() : shape.sortPoints(ip);\n\n    let multiline = new Multiline([shape]);\n    multiline.split(ip_sorted);\n\n    [...multiline].forEach(edge => edge.setInclusion(polygon));\n\n    denim.I2I = [...multiline].filter(edge => edge.bv === Flatten.INSIDE).map(edge => edge.shape);\n    denim.I2B = [...multiline].slice(1).map( (edge) => edge.bv === Flatten.BOUNDARY ? edge.shape : edge.shape.start );\n    denim.I2E = [...multiline].filter(edge => edge.bv === Flatten.OUTSIDE).map(edge => edge.shape);\n\n\n    denim.B2I = [];\n    denim.B2B = [];\n    denim.B2E = [];\n    for (let pt of [shape.start, shape.end]) {\n        switch (ray_shoot(polygon, pt)) {\n            case Flatten.INSIDE:\n                denim.B2I.push(pt);\n                break;\n            case Flatten.BOUNDARY:\n                denim.B2B.push(pt);\n                break;\n            case Flatten.OUTSIDE:\n                denim.B2E.push(pt);\n                break;\n            default:\n                break;\n        }\n    }\n\n    // denim.E2I  TODO: calculate, not clear what is expected result\n\n    return denim;\n}\n\nfunction relatePolygon2Polygon(polygon1, polygon2) {\n    let denim = new DE9IM();\n\n    let [ip_sorted1, ip_sorted2] = calculateIntersections(polygon1, polygon2);\n    let boolean_intersection = intersect(polygon1, polygon2);\n    let boolean_difference1 = subtract(polygon1, polygon2);\n    let boolean_difference2 = subtract(polygon2, polygon1);\n    let [inner_clip_shapes1, inner_clip_shapes2] = innerClip(polygon1, polygon2);\n    let outer_clip_shapes1 = outerClip(polygon1, polygon2);\n    let outer_clip_shapes2 = outerClip(polygon2, polygon1);\n\n    denim.I2I = boolean_intersection.isEmpty() ? [] : [boolean_intersection];\n    denim.I2B = inner_clip_shapes2;\n    denim.I2E = boolean_difference1.isEmpty() ? [] : [boolean_difference1];\n\n    denim.B2I = inner_clip_shapes1;\n    denim.B2B = ip_sorted1;\n    denim.B2E = outer_clip_shapes1;\n\n    denim.E2I = boolean_difference2.isEmpty() ? [] : [boolean_difference2];\n    denim.E2B = outer_clip_shapes2;\n    // denim.E2E    not relevant meanwhile\n\n    return denim;\n}\n\nvar Relations = /*#__PURE__*/Object.freeze({\n    equal: equal,\n    intersect: intersect$1,\n    touch: touch,\n    disjoint: disjoint,\n    inside: inside,\n    covered: covered,\n    contain: contain,\n    cover: cover,\n    relate: relate\n});\n\n/**\n * Class representing an affine transformation 3x3 matrix:\n * <pre>\n *      [ a  c  tx\n * A =    b  d  ty\n *        0  0  1  ]\n * </pre\n * @type {Matrix}\n */\nclass Matrix {\n    /**\n     * Construct new instance of affine transformation matrix <br/>\n     * If parameters omitted, construct identity matrix a = 1, d = 1\n     * @param {number} a - position(0,0)   sx*cos(alpha)\n     * @param {number} b - position (0,1)  sx*sin(alpha)\n     * @param {number} c - position (1,0)  -sy*sin(alpha)\n     * @param {number} d - position (1,1)  sy*cos(alpha)\n     * @param {number} tx - position (2,0) translation by x\n     * @param {number} ty - position (2,1) translation by y\n     */\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n    }\n\n    /**\n     * Return new cloned instance of matrix\n     * @return {Matrix}\n     **/\n    clone() {\n        return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);\n    };\n\n    /**\n     * Transform vector [x,y] using transformation matrix. <br/>\n     * Vector [x,y] is an abstract array[2] of numbers and not a FlattenJS object <br/>\n     * The result is also an abstract vector [x',y'] = A * [x,y]:\n     * <code>\n     * [x'       [ ax + by + tx\n     *  y'   =     cx + dy + ty\n     *  1]                    1 ]\n     * </code>\n     * @param {number[]} vector - array[2] of numbers\n     * @returns {number[]} transformation result - array[2] of numbers\n     */\n    transform(vector) {\n        return [\n            vector[0] * this.a + vector[1] * this.c + this.tx,\n            vector[0] * this.b + vector[1] * this.d + this.ty\n        ]\n    };\n\n    /**\n     * Returns result of multiplication of this matrix by other matrix\n     * @param {Matrix} other_matrix - matrix to multiply by\n     * @returns {Matrix}\n     */\n    multiply(other_matrix) {\n        return new Matrix(\n            this.a * other_matrix.a + this.c * other_matrix.b,\n            this.b * other_matrix.a + this.d * other_matrix.b,\n            this.a * other_matrix.c + this.c * other_matrix.d,\n            this.b * other_matrix.c + this.d * other_matrix.d,\n            this.a * other_matrix.tx + this.c * other_matrix.ty + this.tx,\n            this.b * other_matrix.tx + this.d * other_matrix.ty + this.ty\n        )\n    };\n\n    /**\n     * Return new matrix as a result of multiplication of the current matrix\n     * by the matrix(1,0,0,1,tx,ty)\n     * @param {number} tx - translation by x\n     * @param {number} ty - translation by y\n     * @returns {Matrix}\n     */\n    translate(...args) {\n        let tx, ty;\n        if (args.length == 1 && (args[0] instanceof Flatten.Vector)) {\n            tx = args[0].x;\n            ty = args[0].y;\n        } else if (args.length == 2 && typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\n            tx = args[0];\n            ty = args[1];\n        } else {\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\n        }\n        return this.multiply(new Matrix(1, 0, 0, 1, tx, ty))\n    };\n\n    /**\n     * Return new matrix as a result of multiplication of the current matrix\n     * by the matrix that defines rotation by given angle (in radians) around\n     * point (0,0) in counter clockwise direction\n     * @param {number} angle - angle in radians\n     * @returns {Matrix}\n     */\n    rotate(angle) {\n        let cos = Math.cos(angle);\n        let sin = Math.sin(angle);\n        return this.multiply(new Matrix(cos, sin, -sin, cos, 0, 0));\n    };\n\n    /**\n     * Return new matrix as a result of multiplication of the current matrix\n     * by the matrix (sx,0,0,sy,0,0) that defines scaling\n     * @param {number} sx\n     * @param {number} sy\n     * @returns {Matrix}\n     */\n    scale(sx, sy) {\n        return this.multiply(new Matrix(sx, 0, 0, sy, 0, 0));\n    };\n\n    /**\n     * Returns true if two matrix are equal parameter by parameter\n     * @param {Matrix} matrix - other matrix\n     * @returns {boolean} true if equal, false otherwise\n     */\n    equalTo(matrix) {\n        if (!Flatten.Utils.EQ(this.tx, matrix.tx)) return false;\n        if (!Flatten.Utils.EQ(this.ty, matrix.ty)) return false;\n        if (!Flatten.Utils.EQ(this.a, matrix.a)) return false;\n        if (!Flatten.Utils.EQ(this.b, matrix.b)) return false;\n        if (!Flatten.Utils.EQ(this.c, matrix.c)) return false;\n        if (!Flatten.Utils.EQ(this.d, matrix.d)) return false;\n        return true;\n    };\n}\nFlatten.Matrix = Matrix;\n/**\n * Function to create matrix equivalent to \"new\" constructor\n * @param args\n */\nconst matrix = (...args) => new Flatten.Matrix(...args);\nFlatten.matrix = matrix;\n\n/**\n * Created by Alex Bol on 4/1/2017.\n */\n\n/**\n * Interval is a pair of numbers or a pair of any comparable objects on which may be defined predicates\n * *equal*, *less* and method *max(p1, p1)* that returns maximum in a pair.\n * When interval is an object rather than pair of numbers, this object should have properties *low*, *high*, *max*\n * and implement methods *less_than(), equal_to(), intersect(), not_intersect(), clone(), output()*.\n * Two static methods *comparable_max(), comparable_less_than()* define how to compare values in pair. <br/>\n * This interface is described in typescript definition file *index.d.ts*\n *\n * Axis aligned rectangle is an example of such interval.\n * We may look at rectangle as an interval between its low left and top right corners.\n * See **Box** class in [flatten-js](https://github.com/alexbol99/flatten-js) library as the example\n * of Interval interface implementation\n * @type {Interval}\n */\nconst Interval = class Interval {\n    /**\n     * Accept two comparable values and creates new instance of interval\n     * Predicate Interval.comparable_less(low, high) supposed to return true on these values\n     * @param low\n     * @param high\n     */\n    constructor(low, high) {\n        this.low = low;\n        this.high = high;\n    }\n\n    /**\n     * Clone interval\n     * @returns {Interval}\n     */\n    clone() {\n        return new Interval(this.low, this.high);\n    }\n\n    /**\n     * Propery max returns clone of this interval\n     * @returns {Interval}\n     */\n    get max() {\n        return this.clone();   // this.high;\n    }\n\n    /**\n     * Predicate returns true is this interval less than other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    less_than(other_interval) {\n        return this.low < other_interval.low ||\n            this.low == other_interval.low && this.high < other_interval.high;\n    }\n\n    /**\n     * Predicate returns true is this interval equals to other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    equal_to(other_interval) {\n        return this.low == other_interval.low && this.high == other_interval.high;\n    }\n\n    /**\n     * Predicate returns true if this interval intersects other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    intersect(other_interval) {\n        return !this.not_intersect(other_interval);\n    }\n\n    /**\n     * Predicate returns true if this interval does not intersect other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    not_intersect(other_interval) {\n        return (this.high < other_interval.low || other_interval.high < this.low);\n    }\n\n    /**\n     * Returns new interval merged with other interval\n     * @param {Interval} interval - Other interval to merge with\n     * @returns {Interval}\n     */\n    merge(other_interval) {\n        return new Interval(\n            this.low === undefined ? other_interval.low : Math.min(this.low, other_interval.low),\n            this.high === undefined ? other_interval.high : Math.max(this.high, other_interval.high)\n        );\n    }\n\n    /**\n     * Returns how key should return\n     */\n    output() {\n        return [this.low, this.high];\n    }\n\n    /**\n     * Function returns maximum between two comparable values\n     * @param interval1\n     * @param interval2\n     * @returns {Interval}\n     */\n    static comparable_max(interval1, interval2) {\n        return interval1.merge(interval2);\n    }\n\n    /**\n     * Predicate returns true if first value less than second value\n     * @param val1\n     * @param val2\n     * @returns {boolean}\n     */\n    static comparable_less_than(val1, val2 ) {\n        return val1 < val2;\n    }\n};\n\n/**\n * Created by Alex Bol on 3/28/2017.\n */\n\n// module.exports = {\n//     RB_TREE_COLOR_RED: 0,\n//     RB_TREE_COLOR_BLACK: 1\n// };\n\nconst RB_TREE_COLOR_RED = 0;\nconst RB_TREE_COLOR_BLACK = 1;\n\n/**\n * Created by Alex Bol on 4/1/2017.\n */\n\nclass Node {\n    constructor(key = undefined, value = undefined,\n                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {\n        this.left = left;                     // reference to left child node\n        this.right = right;                   // reference to right child node\n        this.parent = parent;                 // reference to parent node\n        this.color = color;\n\n        this.item = {key: key, value: value};   // key is supposed to be instance of Interval\n\n        /* If not, this should by an array of two numbers */\n        if (key && key instanceof Array && key.length == 2) {\n            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {\n                this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));\n            }\n        }\n\n        this.max = this.item.key ? this.item.key.max : undefined;\n    }\n\n    isNil() {\n        return (this.item.key === undefined && this.item.value === undefined &&\n            this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK);\n    }\n\n    less_than(other_node) {\n        // if tree stores only keys\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\n            return this.item.key.less_than(other_node.item.key);\n        }\n        else {    // if tree stores keys and values\n            let value_less_than = this.item.value && other_node.item.value && this.item.value.less_than ? this.item.value.less_than(other_node.item.value) :\n                this.item.value < other_node.item.value;\n            return this.item.key.less_than(other_node.item.key) ||\n                this.item.key.equal_to((other_node.item.key)) && value_less_than;\n        }\n\n        // if (this.item.value && other_node.item.value) {\n        //     let item_less_than = this.item.value.less_than ? this.item.value.less_than(other_node.item.value) :\n        //         this.item.value < other_node.item.value;\n        //     return this.item.key.less_than(other_node.item.key) ||\n        //         this.item.key.equal_to((other_node.item.key)) && item_less_than;\n        // }\n        // else {\n        //     return this.item.key.less_than(other_node.item.key);\n        // }\n    }\n\n    equal_to(other_node) {\n        // if tree stores only keys\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\n            return this.item.key.equal_to(other_node.item.key);\n        }\n        else {    // if tree stores keys and values\n            let value_equal = this.item.value && other_node.item.value && this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) :\n                this.item.value == other_node.item.value;\n            return this.item.key.equal_to(other_node.item.key) && value_equal;\n        }\n\n        // let value_equal = true;\n        // if (this.item.value && other_node.item.value) {\n        //     value_equal = this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) :\n        //         this.item.value == other_node.item.value;\n        // }\n        // return this.item.key.equal_to(other_node.item.key) && value_equal;\n    }\n\n    intersect(other_node) {\n        return this.item.key.intersect(other_node.item.key);\n    }\n\n    copy_data(other_node) {\n        this.item.key = other_node.item.key.clone();\n        this.item.value = other_node.item.value && other_node.item.value.clone ? other_node.item.value.clone() : other_node.item.value;\n    }\n\n    update_max() {\n        // use key (Interval) max property instead of key.high\n        this.max = this.item.key ? this.item.key.max : undefined;\n        if (this.right && this.right.max) {\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\n            this.max = comparable_max(this.max, this.right.max);\n        }\n        if (this.left && this.left.max) {\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\n            this.max = comparable_max(this.max, this.left.max);\n        }\n    }\n\n    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\n    not_intersect_left_subtree(search_node) {\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\n        let high = this.left.max.high !== undefined ? this.left.max.high : this.left.max;\n        return comparable_less_than(high, search_node.item.key.low);\n    }\n\n    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\n    not_intersect_right_subtree(search_node) {\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\n        let low = this.right.max.low !== undefined ? this.right.max.low : this.right.item.key.low;\n        return comparable_less_than(search_node.item.key.high, low);\n    }\n}\n\n/**\n * Created by Alex Bol on 3/31/2017.\n */\n\n// const nil_node = new Node();\n\n/**\n * Implementation of interval binary search tree <br/>\n * Interval tree stores items which are couples of {key:interval, value: value} <br/>\n * Interval is an object with high and low properties or simply pair [low,high] of numeric values <br />\n * @type {IntervalTree}\n */\nclass IntervalTree {\n    /**\n     * Construct new empty instance of IntervalTree\n     */\n    constructor() {\n        this.root = null;\n        this.nil_node = new Node();\n    }\n\n    /**\n     * Returns number of items stored in the interval tree\n     * @returns {number}\n     */\n    get size() {\n        let count = 0;\n        this.tree_walk(this.root, () => count++);\n        return count;\n    }\n\n    /**\n     * Returns array of sorted keys in the ascending order\n     * @returns {Array}\n     */\n    get keys() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push(\n            node.item.key.output ? node.item.key.output() : node.item.key\n        ));\n        return res;\n    }\n\n    /**\n     * Return array of values in the ascending keys order\n     * @returns {Array}\n     */\n    get values() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push(node.item.value));\n        return res;\n    }\n\n    /**\n     * Returns array of items (<key,value> pairs) in the ascended keys order\n     * @returns {Array}\n     */\n    get items() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push({\n            key: node.item.key.output ? node.item.key.output() : node.item.key,\n            value: node.item.value\n        }));\n        return res;\n    }\n\n    /**\n     * Returns true if tree is empty\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return (this.root == null || this.root == this.nil_node);\n    }\n\n    /**\n     * Insert new item into interval tree\n     * @param {Interval} key - interval object or array of two numbers [low, high]\n     * @param {any} value - value representing any object (optional)\n     * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}\n     */\n    insert(key, value = key) {\n        if (key === undefined) return;\n        let insert_node = new Node(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);\n        this.tree_insert(insert_node);\n        this.recalc_max(insert_node);\n        return insert_node;\n    }\n\n    /**\n     * Returns true if item {key,value} exist in the tree\n     * @param {Interval} key - interval correspondent to keys stored in the tree\n     * @param {any} value - value object to be checked\n     * @returns {boolean} true if item {key, value} exist in the tree, false otherwise\n     */\n    exist(key, value = key) {\n        let search_node = new Node(key, value);\n        return this.tree_search(this.root, search_node) ? true : false;\n    }\n\n    /**\n     * Remove entry {key, value} from the tree\n     * @param {Interval} key - interval correspondent to keys stored in the tree\n     * @param {any} value - value object\n     * @returns {boolean} true if item {key, value} deleted, false if not found\n     */\n    remove(key, value = key) {\n        let search_node = new Node(key, value);\n        let delete_node = this.tree_search(this.root, search_node);\n        if (delete_node) {\n            this.tree_delete(delete_node);\n        }\n        return delete_node;\n    }\n\n    /**\n     * Returns array of entry values which keys intersect with given interval <br/>\n     * If no values stored in the tree, returns array of keys which intersect given interval\n     * @param {Interval} interval - search interval, or tuple [low, high]\n     * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\n     * @returns {Array}\n     */\n    search(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\n        let search_node = new Node(interval);\n        let resp_nodes = [];\n        this.tree_search_interval(this.root, search_node, resp_nodes);\n        return resp_nodes.map(node => outputMapperFn(node.item.value, node.item.key))\n    }\n\n    /**\n     * Returns true if intersection between given and any interval stored in the tree found\n     * @param {Interval} interval - search interval or tuple [low, high]\n     * @returns {boolean}\n     */\n    intersect_any(interval) {\n        let search_node = new Node(interval);\n        let found = this.tree_find_any_interval(this.root, search_node);\n        return found;\n    }\n\n    /**\n     * Tree visitor. For each node implement a callback function. <br/>\n     * Method calls a callback function with two parameters (key, value)\n     * @param visitor(key,value) - function to be called for each tree item\n     */\n    forEach(visitor) {\n        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));\n    }\n\n    /** Value Mapper. Walk through every node and map node value to another value\n    * @param callback(value,key) - function to be called for each tree item\n    */\n    map(callback) {\n        const tree = new IntervalTree();\n        this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));\n        return tree;\n    }\n\n    recalc_max(node) {\n        let node_current = node;\n        while (node_current.parent != null) {\n            node_current.parent.update_max();\n            node_current = node_current.parent;\n        }\n    }\n\n    tree_insert(insert_node) {\n        let current_node = this.root;\n        let parent_node = null;\n\n        if (this.root == null || this.root == this.nil_node) {\n            this.root = insert_node;\n        }\n        else {\n            while (current_node != this.nil_node) {\n                parent_node = current_node;\n                if (insert_node.less_than(current_node)) {\n                    current_node = current_node.left;\n                }\n                else {\n                    current_node = current_node.right;\n                }\n            }\n\n            insert_node.parent = parent_node;\n\n            if (insert_node.less_than(parent_node)) {\n                parent_node.left = insert_node;\n            }\n            else {\n                parent_node.right = insert_node;\n            }\n        }\n\n        this.insert_fixup(insert_node);\n    }\n\n// After insertion insert_node may have red-colored parent, and this is a single possible violation\n// Go upwords to the root and re-color until violation will be resolved\n    insert_fixup(insert_node) {\n        let current_node;\n        let uncle_node;\n\n        current_node = insert_node;\n        while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {\n            if (current_node.parent == current_node.parent.parent.left) {   // parent is left child of grandfather\n                uncle_node = current_node.parent.parent.right;              // right brother of parent\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 1. Uncle is red\n                    // re-color father and uncle into black\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent.parent;\n                }\n                else {                                                    // Case 2 & 3. Uncle is black\n                    if (current_node == current_node.parent.right) {     // Case 2. Current if right child\n                        // This case is transformed into Case 3.\n                        current_node = current_node.parent;\n                        this.rotate_left(current_node);\n                    }\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.\n                    // Re-color father and grandfather, rotate grandfather right\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_right(current_node.parent.parent);\n                }\n            }\n            else {                                                         // parent is right child of grandfather\n                uncle_node = current_node.parent.parent.left;              // left brother of parent\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 4. Uncle is red\n                    // re-color father and uncle into black\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent.parent;\n                }\n                else {\n                    if (current_node == current_node.parent.left) {             // Case 5. Current is left child\n                        // Transform into case 6\n                        current_node = current_node.parent;\n                        this.rotate_right(current_node);\n                    }\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.\n                    // Re-color father and grandfather, rotate grandfather left\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_left(current_node.parent.parent);\n                }\n            }\n        }\n\n        this.root.color = RB_TREE_COLOR_BLACK;\n    }\n\n    tree_delete(delete_node) {\n        let cut_node;   // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\n        let fix_node;   // node to fix rb tree property   (\"x\" from 14.4)\n\n        if (delete_node.left == this.nil_node || delete_node.right == this.nil_node) {  // delete_node has less then 2 children\n            cut_node = delete_node;\n        }\n        else {                                                    // delete_node has 2 children\n            cut_node = this.tree_successor(delete_node);\n        }\n\n        // fix_node if single child of cut_node\n        if (cut_node.left != this.nil_node) {\n            fix_node = cut_node.left;\n        }\n        else {\n            fix_node = cut_node.right;\n        }\n\n        // remove cut_node from parent\n        /*if (fix_node != this.nil_node) {*/\n            fix_node.parent = cut_node.parent;\n        /*}*/\n\n        if (cut_node == this.root) {\n            this.root = fix_node;\n        }\n        else {\n            if (cut_node == cut_node.parent.left) {\n                cut_node.parent.left = fix_node;\n            }\n            else {\n                cut_node.parent.right = fix_node;\n            }\n            cut_node.parent.update_max();        // update max property of the parent\n        }\n\n        this.recalc_max(fix_node);              // update max property upward from fix_node to root\n\n        // COPY DATA !!!\n        // Delete_node becomes cut_node, it means that we cannot hold reference\n        // to node in outer structure and we will have to delete by key, additional search need\n        if (cut_node != delete_node) {\n            delete_node.copy_data(cut_node);\n            delete_node.update_max();           // update max property of the cut node at the new place\n            this.recalc_max(delete_node);       // update max property upward from delete_node to root\n        }\n\n        if (/*fix_node != this.nil_node && */cut_node.color == RB_TREE_COLOR_BLACK) {\n            this.delete_fixup(fix_node);\n        }\n    }\n\n    delete_fixup(fix_node) {\n        let current_node = fix_node;\n        let brother_node;\n\n        while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {\n            if (current_node == current_node.parent.left) {          // fix node is left child\n                brother_node = current_node.parent.right;\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\n                    this.rotate_left(current_node.parent);\n                    brother_node = current_node.parent.right;                      // update brother\n                }\n                // Derive to cases 2..4: brother is black\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {  // case 2: both nephews black\n                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother\n                    current_node = current_node.parent;                  // continue iteration\n                }\n                else {\n                    if (brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black\n                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother\n                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew\n                        this.rotate_right(brother_node);\n                        brother_node = current_node.parent.right;                     // update brother\n                        // Derive to case 4: left nephew black, right nephew red\n                    }\n                    // case 4: left nephew black, right nephew red\n                    brother_node.color = current_node.parent.color;\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    brother_node.right.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_left(current_node.parent);\n                    current_node = this.root;                         // exit from loop\n                }\n            }\n            else {                                             // fix node is right child\n                brother_node = current_node.parent.left;\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\n                    this.rotate_right(current_node.parent);\n                    brother_node = current_node.parent.left;                        // update brother\n                }\n                // Go to cases 2..4\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 2\n                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother\n                    current_node = current_node.parent;                              // continue iteration\n                }\n                else {\n                    if (brother_node.left.color == RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black\n                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother\n                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew\n                        this.rotate_left(brother_node);\n                        brother_node = current_node.parent.left;                        // update brother\n                        // Derive to case 4: right nephew black, left nephew red\n                    }\n                    // case 4: right nephew black, left nephew red\n                    brother_node.color = current_node.parent.color;\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    brother_node.left.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_right(current_node.parent);\n                    current_node = this.root;                               // force exit from loop\n                }\n            }\n        }\n\n        current_node.color = RB_TREE_COLOR_BLACK;\n    }\n\n    tree_search(node, search_node) {\n        if (node == null || node == this.nil_node)\n            return undefined;\n\n        if (search_node.equal_to(node)) {\n            return node;\n        }\n        if (search_node.less_than(node)) {\n            return this.tree_search(node.left, search_node);\n        }\n        else {\n            return this.tree_search(node.right, search_node);\n        }\n    }\n\n    // Original search_interval method; container res support push() insertion\n    // Search all intervals intersecting given one\n    tree_search_interval(node, search_node, res) {\n        if (node != null && node != this.nil_node) {\n            // if (node->left != this.nil_node && node->left->max >= low) {\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                this.tree_search_interval(node.left, search_node, res);\n            }\n            // if (low <= node->high && node->low <= high) {\n            if (node.intersect(search_node)) {\n                res.push(node);\n            }\n            // if (node->right != this.nil_node && node->low <= high) {\n            if (node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                this.tree_search_interval(node.right, search_node, res);\n            }\n        }\n    }\n\n    tree_find_any_interval(node, search_node) {\n        let found = false;\n        if (node != null && node != this.nil_node) {\n            // if (node->left != this.nil_node && node->left->max >= low) {\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.left, search_node);\n            }\n            // if (low <= node->high && node->low <= high) {\n            if (!found) {\n                found = node.intersect(search_node);\n            }\n            // if (node->right != this.nil_node && node->low <= high) {\n            if (!found && node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.right, search_node);\n            }\n        }\n        return found;\n    }\n\n    local_minimum(node) {\n        let node_min = node;\n        while (node_min.left != null && node_min.left != this.nil_node) {\n            node_min = node_min.left;\n        }\n        return node_min;\n    }\n\n    // not in use\n    local_maximum(node) {\n        let node_max = node;\n        while (node_max.right != null && node_max.right != this.nil_node) {\n            node_max = node_max.right;\n        }\n        return node_max;\n    }\n\n    tree_successor(node) {\n        let node_successor;\n        let current_node;\n        let parent_node;\n\n        if (node.right != this.nil_node) {\n            node_successor = this.local_minimum(node.right);\n        }\n        else {\n            current_node = node;\n            parent_node = node.parent;\n            while (parent_node != null && parent_node.right == current_node) {\n                current_node = parent_node;\n                parent_node = parent_node.parent;\n            }\n            node_successor = parent_node;\n        }\n        return node_successor;\n    }\n\n    //           |            right-rotate(T,y)       |\n    //           y            ---------------.       x\n    //          / \\                                  / \\\n    //         x   c          left-rotate(T,x)      a   y\n    //        / \\             <---------------         / \\\n    //       a   b                                    b   c\n\n    rotate_left(x) {\n        let y = x.right;\n\n        x.right = y.left;           // b goes to x.right\n\n        if (y.left != this.nil_node) {\n            y.left.parent = x;     // x becomes parent of b\n        }\n        y.parent = x.parent;       // move parent\n\n        if (x == this.root) {\n            this.root = y;           // y becomes root\n        }\n        else {                        // y becomes child of x.parent\n            if (x == x.parent.left) {\n                x.parent.left = y;\n            }\n            else {\n                x.parent.right = y;\n            }\n        }\n        y.left = x;                 // x becomes left child of y\n        x.parent = y;               // and y becomes parent of x\n\n        if (x != null && x != this.nil_node) {\n            x.update_max();\n        }\n\n        y = x.parent;\n        if (y != null && y != this.nil_node) {\n            y.update_max();\n        }\n    }\n\n    rotate_right(y) {\n        let x = y.left;\n\n        y.left = x.right;           // b goes to y.left\n\n        if (x.right != this.nil_node) {\n            x.right.parent = y;        // y becomes parent of b\n        }\n        x.parent = y.parent;          // move parent\n\n        if (y == this.root) {        // x becomes root\n            this.root = x;\n        }\n        else {                        // y becomes child of x.parent\n            if (y == y.parent.left) {\n                y.parent.left = x;\n            }\n            else {\n                y.parent.right = x;\n            }\n        }\n        x.right = y;                 // y becomes right child of x\n        y.parent = x;               // and x becomes parent of y\n\n        if (y != null && y != this.nil_node) {\n            y.update_max();\n        }\n\n        x = y.parent;\n        if (x != null && x != this.nil_node) {\n            x.update_max();\n        }\n    }\n\n    tree_walk(node, action) {\n        if (node != null && node != this.nil_node) {\n            this.tree_walk(node.left, action);\n            // arr.push(node.toArray());\n            action(node);\n            this.tree_walk(node.right, action);\n        }\n    }\n\n    /* Return true if all red nodes have exactly two black child nodes */\n    testRedBlackProperty() {\n        let res = true;\n        this.tree_walk(this.root, function (node) {\n            if (node.color == RB_TREE_COLOR_RED) {\n                if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {\n                    res = false;\n                }\n            }\n        });\n        return res;\n    }\n\n    /* Throw error if not every path from root to bottom has same black height */\n    testBlackHeightProperty(node) {\n        let height = 0;\n        let heightLeft = 0;\n        let heightRight = 0;\n        if (node.color == RB_TREE_COLOR_BLACK) {\n            height++;\n        }\n        if (node.left != this.nil_node) {\n            heightLeft = this.testBlackHeightProperty(node.left);\n        }\n        else {\n            heightLeft = 1;\n        }\n        if (node.right != this.nil_node) {\n            heightRight = this.testBlackHeightProperty(node.right);\n        }\n        else {\n            heightRight = 1;\n        }\n        if (heightLeft != heightRight) {\n            throw new Error('Red-black height property violated');\n        }\n        height += heightLeft;\n        return height;\n    };\n}\n\n/**\n * Created by Alex Bol on 3/12/2017.\n */\n\n/**\n * Class representing a planar set - a generic container with ability to keep and retrieve shapes and\n * perform spatial queries. Planar set is an extension of Set container, so it supports\n * Set properties and methods\n */\nclass PlanarSet extends Set {\n    /**\n     * Create new instance of PlanarSet\n     * @param shapes - array or set of geometric objects to store in planar set\n     * Each object should have a <b>box</b> property\n     */\n    constructor(shapes) {\n        super(shapes);\n        this.index = new IntervalTree();\n        this.forEach(shape => this.index.insert(shape));\n    }\n\n    /**\n     * Add new shape to planar set and to its spatial index.<br/>\n     * If shape already exist, it will not be added again.\n     * This happens with no error, it is possible to use <i>size</i> property to check if\n     * a shape was actually added.<br/>\n     * Method returns planar set object updated and may be chained\n     * @param {Shape} shape - shape to be added, should have valid <i>box</i> property\n     * @returns {PlanarSet}\n     */\n    add(shape) {\n        let size = this.size;\n        super.add(shape);\n        // size not changed - item not added, probably trying to add same item twice\n        if (this.size > size) {\n            let node = this.index.insert(shape.box, shape);\n        }\n        return this;         // in accordance to Set.add interface\n    }\n\n    /**\n     * Delete shape from planar set. Returns true if shape was actually deleted, false otherwise\n     * @param {Shape} shape - shape to be deleted\n     * @returns {boolean}\n     */\n    delete(shape) {\n        let deleted = super.delete(shape);\n        if (deleted) {\n            this.index.remove(shape.box, shape);\n        }\n        return deleted;\n    }\n\n    /**\n     * Clear planar set\n     */\n    clear() {\n        super.clear();\n        this.index = new IntervalTree();\n    }\n\n    /**\n     * 2d range search in planar set.<br/>\n     * Returns array of all shapes in planar set which bounding box is intersected with query box\n     * @param {Box} box - query box\n     * @returns {Shapes[]}\n     */\n    search(box) {\n        let resp = this.index.search(box);\n        return resp;\n    }\n\n    /**\n     * Point location test. Returns array of shapes which contains given point\n     * @param {Point} point - query point\n     * @returns {Array}\n     */\n    hit(point) {\n        let box = new Flatten.Box(point.x - 1, point.y - 1, point.x + 1, point.y + 1);\n        let resp = this.index.search(box);\n        return resp.filter((shape) => point.on(shape));\n    }\n\n    /**\n     * Returns svg string to draw all shapes in planar set\n     * @returns {String}\n     */\n    svg() {\n        let svgcontent = [...this].reduce((acc, shape) => acc + shape.svg(), \"\");\n        return svgcontent;\n    }\n}\n\nFlatten.PlanarSet = PlanarSet;\n\n/**\n * Created by Alex Bol on 2/18/2017.\n */\n\n/**\n *\n * Class representing a point\n * @type {Point}\n */\nclass Point {\n    /**\n     * Point may be constructed by two numbers, or by array of two numbers\n     * @param {number} x - x-coordinate (float number)\n     * @param {number} y - y-coordinate (float number)\n     */\n    constructor(...args) {\n        /**\n         * x-coordinate (float number)\n         * @type {number}\n         */\n        this.x = 0;\n        /**\n         * y-coordinate (float number)\n         * @type {number}\n         */\n        this.y = 0;\n\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\n            let arr = args[0];\n            if (typeof (arr[0]) == \"number\" && typeof (arr[1]) == \"number\") {\n                this.x = arr[0];\n                this.y = arr[1];\n                return;\n            }\n        }\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"point\") {\n            let {x, y} = args[0];\n            this.x = x;\n            this.y = y;\n            return;\n        }\n\n        if (args.length === 2) {\n            if (typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\n                this.x = args[0];\n                this.y = args[1];\n                return;\n            }\n        }\n\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\n\n    }\n\n    /**\n     * Returns bounding box of a point\n     * @returns {Box}\n     */\n    get box() {\n        return new Flatten.Box(this.x, this.y, this.x, this.y);\n    }\n\n    /**\n     * Return new cloned instance of point\n     * @returns {Point}\n     */\n    clone() {\n        return new Flatten.Point(this.x, this.y);\n    }\n\n    get vertices() {\n        return [this.clone()];\n    }\n\n    /**\n     * Returns true if points are equal up to [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    equalTo(pt) {\n        return Flatten.Utils.EQ(this.x, pt.x) && Flatten.Utils.EQ(this.y, pt.y);\n    }\n\n    /**\n     * Defines predicate \"less than\" between points. Returns true if the point is less than query points, false otherwise <br/>\n     * By definition point1 < point2 if {point1.y < point2.y || point1.y == point2.y && point1.x < point2.x <br/>\n     * Numeric values compared with [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    lessThan(pt) {\n        if (Flatten.Utils.LT(this.y, pt.y))\n            return true;\n        if (Flatten.Utils.EQ(this.y, pt.y) && Flatten.Utils.LT(this.x, pt.x))\n            return true;\n        return false;\n    }\n\n    /**\n     * Returns new point rotated by given angle around given center point.\n     * If center point is omitted, rotates around zero point (0,0).\n     * Positive value of angle defines rotation in counter clockwise direction,\n     * negative angle defines rotation in clockwise clockwise direction\n     * @param {number} angle - angle in radians\n     * @param {Point} [center=(0,0)] center\n     * @returns {Point}\n     */\n    rotate(angle, center = {x: 0, y: 0}) {\n        var x_rot = center.x + (this.x - center.x) * Math.cos(angle) - (this.y - center.y) * Math.sin(angle);\n        var y_rot = center.y + (this.x - center.x) * Math.sin(angle) + (this.y - center.y) * Math.cos(angle);\n\n        return new Flatten.Point(x_rot, y_rot);\n    }\n\n    /**\n     * Returns new point translated by given vector.\n     * Translation vector may by also defined by a pair of numbers.\n     * @param {Vector} vector - Translation vector defined as Flatten.Vector or\n     * @param {number|number} - Translation vector defined as pair of numbers\n     * @returns {Point}\n     */\n    translate(...args) {\n        if (args.length == 1 &&\n            (args[0] instanceof Flatten.Vector || !isNaN(args[0].x) && !isNaN(args[0].y))) {\n            return new Flatten.Point(this.x + args[0].x, this.y + args[0].y);\n        }\n\n        if (args.length == 2 && typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\n            return new Flatten.Point(this.x + args[0], this.y + args[1]);\n        }\n\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Return new point transformed by affine transformation matrix m\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\n     * @returns {Point}\n     */\n    transform(m) {\n        // let [x,y] = m.transform([this.x,this.y]);\n        return new Flatten.Point(m.transform([this.x, this.y]))\n    }\n\n    /**\n     * Returns projection point on given line\n     * @param {Line} line Line this point be projected on\n     * @returns {Point}\n     */\n    projectionOn(line) {\n        if (this.equalTo(line.pt))                   // this point equal to line anchor point\n            return this.clone();\n\n        let vec = new Flatten.Vector(this, line.pt);\n        if (Flatten.Utils.EQ_0(vec.cross(line.norm)))    // vector to point from anchor point collinear to normal vector\n            return line.pt.clone();\n\n        let dist = vec.dot(line.norm);             // signed distance\n        let proj_vec = line.norm.multiply(dist);\n        return this.translate(proj_vec);\n    }\n\n    /**\n     * Returns true if point belongs to the \"left\" semi-plane, which means, point belongs to the same semi plane where line normal vector points to\n     * Return false if point belongs to the \"right\" semi-plane or to the line itself\n     * @param {Line} line Query line\n     * @returns {boolean}\n     */\n    leftTo(line) {\n        let vec = new Flatten.Vector(line.pt, this);\n        let onLeftSemiPlane = Flatten.Utils.GT(vec.dot(line.norm), 0);\n        return onLeftSemiPlane;\n    }\n\n    /**\n     * Calculate distance and shortest segment from point to shape and return as array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from point to shape\n     * @returns {Segment} shortest segment between point and shape (started at point, ended at shape)\n     */\n    distanceTo(shape) {\n        if (shape instanceof Point) {\n            let dx = shape.x - this.x;\n            let dy = shape.y - this.y;\n            return [Math.sqrt(dx * dx + dy * dy), new Flatten.Segment(this, shape)];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return Flatten.Distance.point2line(this, shape);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return Flatten.Distance.point2circle(this, shape);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return Flatten.Distance.point2segment(this, shape);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            // let [dist, ...rest] = Distance.point2arc(this, shape);\n            // return dist;\n            return Flatten.Distance.point2arc(this, shape);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            // let [dist, ...rest] = Distance.point2polygon(this, shape);\n            // return dist;\n            return Flatten.Distance.point2polygon(this, shape);\n        }\n\n        if (shape instanceof Flatten.PlanarSet) {\n            return Flatten.Distance.shape2planarSet(this, shape);\n        }\n    }\n\n    /**\n     * Returns true if point is on a shape, false otherwise\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon\n     * @returns {boolean}\n     */\n    on(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.equalTo(shape);\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return shape.contains(this);\n        }\n    }\n\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */\n    toJSON() {\n        return Object.assign({}, this, {name: \"point\"});\n    }\n\n    /**\n     * Return string to draw point in svg as circle with radius \"r\" <br/>\n     * Accept any valid attributes of svg elements as svg object\n     * Defaults attribues are: <br/>\n     * {\n     *    r:\"3\",\n     *    stroke:\"black\",\n     *    strokeWidth:\"1\",\n     *    fill:\"red\"\n     * }\n     * @param {Object} attrs - Any valid attributes of svg circle element, like \"r\", \"stroke\", \"strokeWidth\", \"fill\"\n     * @returns {String}\n     */\n    svg(attrs = {}) {\n        let {r, stroke, strokeWidth, fill, id, className} = attrs;\n        // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\n        return `\\n<circle cx=\"${this.x}\" cy=\"${this.y}\" r=\"${r || 3}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"red\"}\" ${id_str} ${class_str} />`;\n    }\n\n}\nFlatten.Point = Point;\n/**\n * Function to create point equivalent to \"new\" constructor\n * @param args\n */\nconst point = (...args) => new Flatten.Point(...args);\nFlatten.point = point;\n\n// export {Point};\n\n/**\n * Created by Alex Bol on 2/19/2017.\n */\n\n/**\n * Class representing a vector\n * @type {Vector}\n */\nclass Vector {\n    /**\n     * Vector may be constructed by two points, or by two float numbers,\n     * or by array of two numbers\n     * @param {Point} ps - start point\n     * @param {Point} pe - end point\n     */\n    constructor(...args) {\n        /**\n         * x-coordinate of a vector (float number)\n         * @type {number}\n         */\n        this.x = 0;\n        /**\n         * y-coordinate of a vector (float number)\n         * @type {number}\n         */\n        this.y = 0;\n\n        /* return zero vector */\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\n            let arr = args[0];\n            if (typeof (arr[0]) == \"number\" && typeof (arr[1]) == \"number\") {\n                this.x = arr[0];\n                this.y = arr[1];\n                return;\n            }\n        }\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"vector\") {\n            let {x, y} = args[0];\n            this.x = x;\n            this.y = y;\n            return;\n        }\n\n        if (args.length === 2) {\n            let a1 = args[0];\n            let a2 = args[1];\n\n            if (typeof (a1) == \"number\" && typeof (a2) == \"number\") {\n                this.x = a1;\n                this.y = a2;\n                return;\n            }\n\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\n                this.x = a2.x - a1.x;\n                this.y = a2.y - a1.y;\n                return;\n            }\n\n        }\n\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Method clone returns new instance of Vector\n     * @returns {Vector}\n     */\n    clone() {\n        return new Flatten.Vector(this.x, this.y);\n    }\n\n    /**\n     * Slope of the vector in radians from 0 to 2PI\n     * @returns {number}\n     */\n    get slope() {\n        let angle = Math.atan2(this.y, this.x);\n        if (angle < 0) angle = 2 * Math.PI + angle;\n        return angle;\n    }\n\n    /**\n     * Length of vector\n     * @returns {number}\n     */\n    get length() {\n        return Math.sqrt(this.dot(this));\n    }\n\n    /**\n     * Returns true if vectors are equal up to [DP_TOL]{@link http://localhost:63342/flatten-js/docs/global.html#DP_TOL}\n     * tolerance\n     * @param {Vector} v\n     * @returns {boolean}\n     */\n    equalTo(v) {\n        return Flatten.Utils.EQ(this.x, v.x) && Flatten.Utils.EQ(this.y, v.y);\n    }\n\n    /**\n     * Returns new vector multiplied by scalar\n     * @param {number} scalar\n     * @returns {Vector}\n     */\n    multiply(scalar) {\n        return (new Flatten.Vector(scalar * this.x, scalar * this.y));\n    }\n\n    /**\n     * Returns scalar product (dot product) of two vectors <br/>\n     * <code>dot_product = (this * v)</code>\n     * @param {Vector} v Other vector\n     * @returns {number}\n     */\n    dot(v) {\n        return (this.x * v.x + this.y * v.y);\n    }\n\n    /**\n     * Returns vector product (cross product) of two vectors <br/>\n     * <code>cross_product = (this x v)</code>\n     * @param {Vector} v Other vector\n     * @returns {number}\n     */\n    cross(v) {\n        return (this.x * v.y - this.y * v.x);\n    }\n\n    /**\n     * Returns unit vector.<br/>\n     * Throw error if given vector has zero length\n     * @returns {Vector}\n     */\n    normalize() {\n        if (!Flatten.Utils.EQ_0(this.length)) {\n            return (new Flatten.Vector(this.x / this.length, this.y / this.length));\n        }\n        throw Flatten.Errors.ZERO_DIVISION;\n    }\n\n    /**\n     * Returns new vector rotated by given angle,\n     * positive angle defines rotation in counter clockwise direction,\n     * negative - in clockwise direction\n     * @param {number} angle - Angle in radians\n     * @returns {Vector}\n     */\n    rotate(angle) {\n        let point = new Flatten.Point(this.x, this.y);\n        let rpoint = point.rotate(angle);\n        return new Flatten.Vector(rpoint.x, rpoint.y);\n    }\n\n    /**\n     * Returns vector rotated 90 degrees counter clockwise\n     * @returns {Vector}\n     */\n    rotate90CCW() {\n        return new Flatten.Vector(-this.y, this.x);\n    };\n\n    /**\n     * Returns vector rotated 90 degrees clockwise\n     * @returns {Vector}\n     */\n    rotate90CW() {\n        return new Flatten.Vector(this.y, -this.x);\n    };\n\n    /**\n     * Return inverted vector\n     * @returns {Vector}\n     */\n    invert() {\n        return new Flatten.Vector(-this.x, -this.y);\n    }\n\n    /**\n     * Return result of addition of other vector to this vector as a new vector\n     * @param {Vector} v Other vector\n     * @returns {Vector}\n     */\n    add(v) {\n        return new Flatten.Vector(this.x + v.x, this.y + v.y);\n    }\n\n    /**\n     * Return result of subtraction of other vector from current vector as a new vector\n     * @param {Vector} v Another vector\n     * @returns {Vector}\n     */\n    subtract(v) {\n        return new Flatten.Vector(this.x - v.x, this.y - v.y);\n    }\n\n    /**\n     * Return angle between this vector and other vector. <br/>\n     * Angle is measured from 0 to 2*PI in the counter clockwise direction\n     * from current vector to other.\n     * @param {Vector} v Another vector\n     * @returns {number}\n     */\n    angleTo(v) {\n        let norm1 = this.normalize();\n        let norm2 = v.normalize();\n        let angle = Math.atan2(norm1.cross(norm2), norm1.dot(norm2));\n        if (angle < 0) angle += 2 * Math.PI;\n        return angle;\n    }\n\n    /**\n     * Return vector projection of the current vector on another vector\n     * @param {Vector} v Another vector\n     * @returns {Vector}\n     */\n    projectionOn(v) {\n        let n = v.normalize();\n        let d = this.dot(n);\n        return n.multiply(d);\n    }\n\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */\n    toJSON() {\n        return Object.assign({}, this, {name: \"vector\"});\n    }\n}\nFlatten.Vector = Vector;\n\n/**\n * Function to create vector equivalent to \"new\" constructor\n * @param args\n */\nconst vector = (...args) => new Flatten.Vector(...args);\nFlatten.vector = vector;\n\n/**\n * Created by Alex Bol on 3/10/2017.\n */\n\n/**\n * Class representing a segment\n * @type {Segment}\n */\nclass Segment {\n    /**\n     *\n     * @param {Point} ps - start point\n     * @param {Point} pe - end point\n     */\n    constructor(...args) {\n        /**\n         * Start point\n         * @type {Point}\n         */\n        this.ps = new Flatten.Point();\n        /**\n         * End Point\n         * @type {Point}\n         */\n        this.pe = new Flatten.Point();\n\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 4) {\n            let coords = args[0];\n            this.ps = new Flatten.Point(coords[0], coords[1]);\n            this.pe = new Flatten.Point(coords[2], coords[3]);\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"segment\") {\n            let {ps, pe} = args[0];\n            this.ps = new Flatten.Point(ps.x, ps.y);\n            this.pe = new Flatten.Point(pe.x, pe.y);\n            return;\n        }\n\n        // second point omitted issue #84\n        if (args.length === 1 && args[0] instanceof Flatten.Point) {\n            this.ps = args[0].clone();\n            return;\n        }\n\n        if (args.length === 2 && args[0] instanceof Flatten.Point && args[1] instanceof Flatten.Point) {\n            this.ps = args[0].clone();\n            this.pe = args[1].clone();\n            return;\n        }\n\n        if (args.length === 4) {\n            this.ps = new Flatten.Point(args[0], args[1]);\n            this.pe = new Flatten.Point(args[2], args[3]);\n            return;\n        }\n\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Return new cloned instance of segment\n     * @returns {Segment}\n     */\n    clone() {\n        return new Flatten.Segment(this.start, this.end);\n    }\n\n    /**\n     * Start point\n     * @returns {Point}\n     */\n    get start() {\n        return this.ps;\n    }\n\n    /**\n     * End point\n     * @returns {Point}\n     */\n    get end() {\n        return this.pe;\n    }\n\n\n    /**\n     * Returns array of start and end point\n     * @returns [Point,Point]\n     */\n    get vertices() {\n        return [this.ps.clone(), this.pe.clone()];\n    }\n\n    /**\n     * Length of a segment\n     * @returns {number}\n     */\n    get length() {\n        return this.start.distanceTo(this.end)[0];\n    }\n\n    /**\n     * Slope of the line - angle to axe x in radians from 0 to 2PI\n     * @returns {number}\n     */\n    get slope() {\n        let vec = new Flatten.Vector(this.start, this.end);\n        return vec.slope;\n    }\n\n    /**\n     * Bounding box\n     * @returns {Box}\n     */\n    get box() {\n        return new Flatten.Box(\n            Math.min(this.start.x, this.end.x),\n            Math.min(this.start.y, this.end.y),\n            Math.max(this.start.x, this.end.x),\n            Math.max(this.start.y, this.end.y)\n        )\n    }\n\n    /**\n     * Returns true if equals to query segment, false otherwise\n     * @param {Seg} seg - query segment\n     * @returns {boolean}\n     */\n    equalTo(seg) {\n        return this.ps.equalTo(seg.ps) && this.pe.equalTo(seg.pe);\n    }\n\n    /**\n     * Returns true if segment contains point\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    contains(pt) {\n        return Flatten.Utils.EQ_0(this.distanceToPoint(pt));\n    }\n\n    /**\n     * Returns array of intersection points between segment and other shape\n     * @param {Shape} shape - Shape of the one of supported types <br/>\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return intersectSegment2Line(this, shape);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return  intersectSegment2Segment(this, shape);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectSegment2Circle(this, shape);\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return intersectSegment2Box(this, shape);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectSegment2Arc(this, shape);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return  intersectSegment2Polygon(this, shape);\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment from segment to shape and return as array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from segment to shape\n     * @returns {Segment} shortest segment between segment and shape (started at segment, ended at shape)\n     */\n    distanceTo(shape) {\n        if (shape instanceof Flatten.Point) {\n            let [dist, shortest_segment] = Flatten.Distance.point2segment(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2circle(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2line(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2segment(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2arc(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.PlanarSet) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\n            return [dist, shortest_segment];\n        }\n    }\n\n    /**\n     * Returns unit vector in the direction from start to end\n     * @returns {Vector}\n     */\n    tangentInStart() {\n        let vec = new Flatten.Vector(this.start, this.end);\n        return vec.normalize();\n    }\n\n    /**\n     * Return unit vector in the direction from end to start\n     * @returns {Vector}\n     */\n    tangentInEnd() {\n        let vec = new Flatten.Vector(this.end, this.start);\n        return vec.normalize();\n    }\n\n    /**\n     * Returns new segment with swapped start and end points\n     * @returns {Segment}\n     */\n    reverse() {\n        return new Segment(this.end, this.start);\n    }\n\n    /**\n     * When point belongs to segment, return array of two segments split by given point,\n     * if point is inside segment. Returns clone of this segment if query point is incident\n     * to start or end point of the segment. Returns empty array if point does not belong to segment\n     * @param {Point} pt Query point\n     * @returns {Segment[]}\n     */\n    split(pt) {\n        if (this.start.equalTo(pt))\n            return [null, this.clone()];\n\n        if (this.end.equalTo(pt))\n            return [this.clone(), null];\n\n        return [\n            new Flatten.Segment(this.start, pt),\n            new Flatten.Segment(pt, this.end)\n        ]\n    }\n\n    /**\n     * Return middle point of the segment\n     * @returns {Point}\n     */\n    middle() {\n        return new Flatten.Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n    }\n\n    /**\n     * Get point at given length\n     * @param {number} length - The length along the segment\n     * @returns {Point}\n     */\n    pointAtLength(length) {\n        if (length > this.length || length < 0) return null;\n        if (length == 0) return this.start;\n        if (length == this.length) return this.end;\n        let factor = length / this.length;\n        return new Flatten.Point(\n            (this.end.x - this.start.x) * factor + this.start.x,\n            (this.end.y - this.start.y) * factor + this.start.y\n        );\n    }\n\n    distanceToPoint(pt) {\n        let [dist, ...rest] = Flatten.Distance.point2segment(pt, this);\n        return dist;\n    };\n\n    definiteIntegral(ymin = 0.0) {\n        let dx = this.end.x - this.start.x;\n        let dy1 = this.start.y - ymin;\n        let dy2 = this.end.y - ymin;\n        return (dx * (dy1 + dy2) / 2);\n    }\n\n    /**\n     * Returns new segment translated by vector vec\n     * @param {Vector} vec\n     * @returns {Segment}\n     */\n    translate(...args) {\n        return new Segment(this.ps.translate(...args), this.pe.translate(...args));\n    }\n\n    /**\n     * Return new segment rotated by given angle around given point\n     * If point omitted, rotate around origin (0,0)\n     * Positive value of angle defines rotation counter clockwise, negative - clockwise\n     * @param {number} angle - rotation angle in radians\n     * @param {Point} center - center point, default is (0,0)\n     * @returns {Segment}\n     */\n    rotate(angle = 0, center = new Flatten.Point()) {\n        let m = new Flatten.Matrix();\n        m = m.translate(center.x, center.y).rotate(angle).translate(-center.x, -center.y);\n        return this.transform(m);\n    }\n\n    /**\n     * Return new segment transformed using affine transformation matrix\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Segment} - transformed segment\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        return new Segment(this.ps.transform(matrix), this.pe.transform(matrix))\n    }\n\n    /**\n     * Returns true if segment start is equal to segment end up to DP_TOL\n     * @returns {boolean}\n     */\n    isZeroLength() {\n        return this.ps.equalTo(this.pe)\n    }\n\n    /**\n     * Sort given array of points from segment start to end, assuming all points lay on the segment\n     * @param {Point[]} - array of points\n     * @returns {Point[]} new array sorted\n     */\n    sortPoints(pts) {\n        let line = new Flatten.Line(this.start, this.end);\n        return line.sortPoints(pts);\n    }\n\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */\n    toJSON() {\n        return Object.assign({}, this, {name: \"segment\"});\n    }\n\n    /**\n     * Return string to draw segment in svg\n     * @param {Object} attrs - an object with attributes for svg path element,\n     * like \"stroke\", \"strokeWidth\" <br/>\n     * Defaults are stroke:\"black\", strokeWidth:\"1\"\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        let {stroke, strokeWidth, id, className} = attrs;\n        // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\n\n        return `\\n<line x1=\"${this.start.x}\" y1=\"${this.start.y}\" x2=\"${this.end.x}\" y2=\"${this.end.y}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" ${id_str} ${class_str} />`;\n\n    }\n\n}\nFlatten.Segment = Segment;\n/**\n * Shortcut method to create new segment\n */\nconst segment = (...args) => new Flatten.Segment(...args);\nFlatten.segment = segment;\n\n/**\n * Created by Alex Bol on 2/20/2017.\n */\n\nlet {vector: vector$1} = Flatten;\n\n/**\n * Class representing a line\n * @type {Line}\n */\nclass Line {\n    /**\n     * Line may be constructed by point and normal vector or by two points that a line passes through\n     * @param {Point} pt - point that a line passes through\n     * @param {Vector|Point} norm - normal vector to a line or second point a line passes through\n     */\n    constructor(...args) {\n        /**\n         * Point a line passes through\n         * @type {Point}\n         */\n        this.pt = new Flatten.Point();\n        /**\n         * Normal vector to a line <br/>\n         * Vector is normalized (length == 1)<br/>\n         * Direction of the vector is chosen to satisfy inequality norm * p >= 0\n         * @type {Vector}\n         */\n        this.norm = new Flatten.Vector(0, 1);\n\n        if (args.length == 0) {\n            return;\n        }\n\n        if (args.length == 1 && args[0] instanceof Object && args[0].name === \"line\") {\n            let {pt, norm} = args[0];\n            this.pt = new Flatten.Point(pt);\n            this.norm = new Flatten.Vector(norm);\n            return;\n        }\n\n        if (args.length == 2) {\n            let a1 = args[0];\n            let a2 = args[1];\n\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\n                this.pt = a1;\n                this.norm = Line.points2norm(a1, a2);\n                if (this.norm.dot(vector$1(this.pt.x,this.pt.y)) >= 0) {\n                    this.norm.invert();\n                }\n                return;\n            }\n\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Vector) {\n                if (Flatten.Utils.EQ_0(a2.x) && Flatten.Utils.EQ_0(a2.y)) {\n                    throw Flatten.Errors.ILLEGAL_PARAMETERS;\n                }\n                this.pt = a1.clone();\n                this.norm = a2.clone();\n                this.norm = this.norm.normalize();\n                if (this.norm.dot(vector$1(this.pt.x,this.pt.y)) >= 0) {\n                    this.norm.invert();\n                }\n                return;\n            }\n\n            if (a1 instanceof Flatten.Vector && a2 instanceof Flatten.Point) {\n                if (Flatten.Utils.EQ_0(a1.x) && Flatten.Utils.EQ_0(a1.y)) {\n                    throw Flatten.Errors.ILLEGAL_PARAMETERS;\n                }\n                this.pt = a2.clone();\n                this.norm = a1.clone();\n                this.norm = this.norm.normalize();\n                if (this.norm.dot(vector$1(this.pt.x,this.pt.y)) >= 0) {\n                    this.norm.invert();\n                }\n                return;\n            }\n        }\n\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Return new cloned instance of line\n     * @returns {Line}\n     */\n    clone() {\n        return new Flatten.Line(this.pt, this.norm);\n    }\n\n    /* The following methods need for implementation of Edge interface\n    /**\n     * Line has no start point\n     * @returns {undefined}\n     */\n    get start() {return undefined;}\n\n    /**\n     * Line has no end point\n     */\n    get end() {return undefined;}\n\n    /**\n     * Return positive infinity number as length\n     * @returns {number}\n     */\n    get length() {return Number.POSITIVE_INFINITY;}\n\n    /**\n     * Returns infinite box\n     * @returns {Box}\n     */\n    get box() {\n        return new Flatten.Box(\n            Number.NEGATIVE_INFINITY,\n            Number.NEGATIVE_INFINITY,\n            Number.POSITIVE_INFINITY,\n            Number.POSITIVE_INFINITY\n        )\n    }\n\n    /**\n     * Middle point is undefined\n     * @returns {undefined}\n     */\n    get middle() {return undefined}\n\n    /**\n     * Slope of the line - angle in radians between line and axe x from 0 to 2PI\n     * @returns {number} - slope of the line\n     */\n    get slope() {\n        let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\n        return vec.slope;\n    }\n\n    /**\n     * Get coefficients [A,B,C] of a standard line equation in the form Ax + By = C\n     * @code [A, B, C] = line.standard\n     * @returns {number[]} - array of coefficients\n     */\n    get standard() {\n        let A = this.norm.x;\n        let B = this.norm.y;\n        let C = this.norm.dot(this.pt);\n\n        return [A, B, C];\n    }\n\n    /**\n     * Return true if parallel or incident to other line\n     * @param {Line} other_line - line to check\n     * @returns {boolean}\n     */\n    parallelTo(other_line) {\n        return Flatten.Utils.EQ_0(this.norm.cross(other_line.norm));\n    }\n\n    /**\n     * Returns true if incident to other line\n     * @param {Line} other_line - line to check\n     * @returns {boolean}\n     */\n    incidentTo(other_line) {\n        return this.parallelTo(other_line) && this.pt.on(other_line);\n    }\n\n    /**\n     * Returns true if point belongs to line\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    contains(pt) {\n        if (this.pt.equalTo(pt)) {\n            return true;\n        }\n        /* Line contains point if vector to point is orthogonal to the line normal vector */\n        let vec = new Flatten.Vector(this.pt, pt);\n        return Flatten.Utils.EQ_0(this.norm.dot(vec));\n    }\n\n    /**\n     * Return coordinate of the point that lays on the line in the transformed\n     * coordinate system where center is the projection of the point(0,0) to\n     * the line and axe y is collinear to the normal vector. <br/>\n     * This method assumes that point lays on the line and does not check it\n     * @param {Point} pt - point on line\n     * @returns {number}\n     */\n    coord(pt) {\n        return vector$1(pt.x, pt.y).cross(this.norm);\n    }\n\n    /**\n     * Returns array of intersection points\n     * @param {Shape} shape - shape to intersect with\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return intersectLine2Line(this, shape);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectLine2Circle(this, shape);\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return intersectLine2Box(this, shape);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return intersectSegment2Line(shape, this);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectLine2Arc(this, shape);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return  intersectLine2Polygon(this, shape);\n        }\n\n    }\n\n    /**\n     * Calculate distance and shortest segment from line to shape and returns array [distance, shortest_segment]\n     * @param {Shape} shape Shape of the one of the types Point, Circle, Segment, Arc, Polygon\n     * @returns {Number}\n     * @returns {Segment}\n     */\n    distanceTo(shape) {\n        if (shape instanceof Flatten.Point) {\n            let [distance, shortest_segment] = Flatten.Distance.point2line(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            let [distance, shortest_segment] = Flatten.Distance.circle2line(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            let [distance, shortest_segment] = Flatten.Distance.segment2line(shape, this);\n            return [distance, shortest_segment.reverse()];\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            let [distance, shortest_segment] = Flatten.Distance.arc2line(shape, this);\n            return [distance, shortest_segment.reverse()];\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            let [distance, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n            return [distance, shortest_segment];\n        }\n    }\n\n    /**\n     * Split line with array of points and return array of shapes\n     * Assumed that all points lay on the line\n     * @param {Point[]}\n     * @returns {Shape[]}\n     */\n    split(pt) {\n        if (pt instanceof Flatten.Point) {\n            return [new Flatten.Ray(pt, this.norm.invert()), new Flatten.Ray(pt, this.norm)]\n        }\n        else {\n            let multiline = new Flatten.Multiline([this]);\n            let sorted_points = this.sortPoints(pt);\n            multiline.split(sorted_points);\n            return multiline.toShapes();\n        }\n    }\n\n    /**\n     * Sort given array of points that lay on line with respect to coordinate on a line\n     * The method assumes that points lay on the line and does not check this\n     * @param {Point[]} pts - array of points\n     * @returns {Point[]} new array sorted\n     */\n    sortPoints(pts) {\n        return pts.slice().sort( (pt1, pt2) => {\n            if (this.coord(pt1) < this.coord(pt2)) {\n                return -1;\n            }\n            if (this.coord(pt1) > this.coord(pt2)) {\n                return 1;\n            }\n            return 0;\n        })\n    }\n\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */\n    toJSON() {\n        return Object.assign({}, this, {name: \"line\"});\n    }\n\n    /**\n     * Return string to draw svg segment representing line inside given box\n     * @param {Box} box Box representing drawing area\n     * @param {Object} attrs - an object with attributes of svg circle element\n     */\n    svg(box, attrs = {}) {\n        let ip = intersectLine2Box(this, box);\n        if (ip.length === 0)\n            return \"\";\n        let ps = ip[0];\n        let pe = ip.length == 2 ? ip[1] : ip.find(pt => !pt.equalTo(ps));\n        if (pe === undefined) pe = ps;\n        let segment = new Flatten.Segment(ps, pe);\n        return segment.svg(attrs);\n    }\n\n    static points2norm(pt1, pt2) {\n        if (pt1.equalTo(pt2)) {\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\n        }\n        let vec = new Flatten.Vector(pt1, pt2);\n        let unit = vec.normalize();\n        return unit.rotate90CCW();\n    }\n}\nFlatten.Line = Line;\n/**\n * Function to create line equivalent to \"new\" constructor\n * @param args\n */\nconst line = (...args) => new Flatten.Line(...args);\nFlatten.line = line;\n\n/**\n * Created by Alex Bol on 3/6/2017.\n */\n\n/**\n * Class representing a circle\n * @type {Circle}\n */\nclass Circle {\n    /**\n     *\n     * @param {Point} pc - circle center point\n     * @param {number} r - circle radius\n     */\n    constructor(...args) {\n        /**\n         * Circle center\n         * @type {Point}\n         */\n        this.pc = new Flatten.Point();\n        /**\n         * Circle radius\n         * @type {number}\n         */\n        this.r = 1;\n\n        if (args.length == 1 && args[0] instanceof Object && args[0].name === \"circle\") {\n            let {pc, r} = args[0];\n            this.pc = new Flatten.Point(pc);\n            this.r = r;\n            return;\n        } else {\n            let [pc, r] = [...args];\n            if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\n            if (r !== undefined) this.r = r;\n            return;\n        }\n\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Return new cloned instance of circle\n     * @returns {Circle}\n     */\n    clone() {\n        return new Flatten.Circle(this.pc.clone(), this.r);\n    }\n\n    /**\n     * Circle center\n     * @returns {Point}\n     */\n    get center() {\n        return this.pc;\n    }\n\n    /**\n     * Circle bounding box\n     * @returns {Box}\n     */\n    get box() {\n        return new Flatten.Box(\n            this.pc.x - this.r,\n            this.pc.y - this.r,\n            this.pc.x + this.r,\n            this.pc.y + this.r\n        );\n    }\n\n    /**\n     * Return true if circle contains shape: no point of shape lies outside of the circle\n     * @param {Shape} shape - test shape\n     * @returns {boolean}\n     */\n    contains(shape) {\n        if (shape instanceof Flatten.Point) {\n            return Flatten.Utils.LE(shape.distanceTo(this.center)[0], this.r);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return Flatten.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) &&\n                Flatten.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return this.intersect(shape).length === 0 &&\n                Flatten.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) &&\n                Flatten.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return this.intersect(shape).length === 0 &&\n                Flatten.Utils.LE(shape.r, this.r) &&\n                Flatten.Utils.LE(shape.center.distanceTo(this.center)[0], this.r);\n        }\n\n        /* TODO: box, polygon */\n    }\n\n    /**\n     * Transform circle to closed arc\n     * @param {boolean} counterclockwise\n     * @returns {Arc}\n     */\n    toArc(counterclockwise = true) {\n        return new Flatten.Arc(this.center, this.r, Math.PI, -Math.PI, counterclockwise);\n    }\n\n    /**\n     * Returns array of intersection points between circle and other shape\n     * @param {Shape} shape Shape of the one of supported types\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n        if (shape instanceof Flatten.Line) {\n            return intersectLine2Circle(shape, this);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return intersectSegment2Circle(shape, this);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectCircle2Circle(shape, this);\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return intersectCircle2Box(this, shape);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectArc2Circle(shape, this);\n        }\n        if (shape instanceof Flatten.Polygon) {\n            return intersectCircle2Polygon(this, shape);\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment from circle to shape and return array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from circle to shape\n     * @returns {Segment} shortest segment between circle and shape (started at circle, ended at shape)\n\n     */\n    distanceTo(shape) {\n        if (shape instanceof Flatten.Point) {\n            let [distance, shortest_segment] = Flatten.Distance.point2circle(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            let [distance, shortest_segment] = Flatten.Distance.circle2circle(this, shape);\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            let [distance, shortest_segment] = Flatten.Distance.circle2line(this, shape);\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            let [distance, shortest_segment] = Flatten.Distance.segment2circle(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            let [distance, shortest_segment] = Flatten.Distance.arc2circle(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            let [distance, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.PlanarSet) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\n            return [dist, shortest_segment];\n        }\n    }\n\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */\n    toJSON() {\n        return Object.assign({}, this, {name: \"circle\"});\n    }\n\n    /**\n     * Return string to draw circle in svg\n     * @param {Object} attrs - an object with attributes of svg circle element,\n     * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\n     * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        let {stroke, strokeWidth, fill, fillOpacity, id, className} = attrs;\n        // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\n\n        return `\\n<circle cx=\"${this.pc.x}\" cy=\"${this.pc.y}\" r=\"${this.r}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} />`;\n    }\n\n}\nFlatten.Circle = Circle;\n/**\n * Shortcut to create new circle\n * @param args\n */\nconst circle = (...args) => new Flatten.Circle(...args);\nFlatten.circle = circle;\n\n/**\n * Created by Alex Bol on 3/10/2017.\n */\n\n/**\n * Class representing a circular arc\n * @type {Arc}\n */\nclass Arc {\n    /**\n     *\n     * @param {Point} pc - arc center\n     * @param {number} r - arc radius\n     * @param {number} startAngle - start angle in radians from 0 to 2*PI\n     * @param {number} endAngle - end angle in radians from 0 to 2*PI\n     * @param {boolean} counterClockwise - arc direction, true - clockwise, false - counter clockwise\n     */\n    constructor(...args) {\n        /**\n         * Arc center\n         * @type {Point}\n         */\n        this.pc = new Flatten.Point();\n        /**\n         * Arc radius\n         * @type {number}\n         */\n        this.r = 1;\n        /**\n         * Arc start angle in radians\n         * @type {number}\n         */\n        this.startAngle = 0;\n        /**\n         * Arc end angle in radians\n         * @type {number}\n         */\n        this.endAngle = 2 * Math.PI;\n        /**\n         * Arc orientation\n         * @type {boolean}\n         */\n        this.counterClockwise = Flatten.CCW;\n\n        if (args.length == 0)\n            return;\n\n        if (args.length == 1 && args[0] instanceof Object && args[0].name === \"arc\") {\n            let {pc, r, startAngle, endAngle, counterClockwise} = args[0];\n            this.pc = new Flatten.Point(pc.x, pc.y);\n            this.r = r;\n            this.startAngle = startAngle;\n            this.endAngle = endAngle;\n            this.counterClockwise = counterClockwise;\n            return;\n        } else {\n            let [pc, r, startAngle, endAngle, counterClockwise] = [...args];\n            if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\n            if (r !== undefined) this.r = r;\n            if (startAngle !== undefined) this.startAngle = startAngle;\n            if (endAngle !== undefined) this.endAngle = endAngle;\n            if (counterClockwise !== undefined) this.counterClockwise = counterClockwise;\n            return;\n        }\n\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Return new cloned instance of arc\n     * @returns {Arc}\n     */\n    clone() {\n        return new Flatten.Arc(this.pc.clone(), this.r, this.startAngle, this.endAngle, this.counterClockwise);\n    }\n\n    /**\n     * Get sweep angle in radians. Sweep angle is non-negative number from 0 to 2*PI\n     * @returns {number}\n     */\n    get sweep() {\n        if (Flatten.Utils.EQ(this.startAngle, this.endAngle))\n            return 0.0;\n        if (Flatten.Utils.EQ(Math.abs(this.startAngle - this.endAngle), Flatten.PIx2)) {\n            return Flatten.PIx2;\n        }\n        let sweep;\n        if (this.counterClockwise) {\n            sweep = Flatten.Utils.GT(this.endAngle, this.startAngle) ?\n                this.endAngle - this.startAngle : this.endAngle - this.startAngle + Flatten.PIx2;\n        } else {\n            sweep = Flatten.Utils.GT(this.startAngle, this.endAngle) ?\n                this.startAngle - this.endAngle : this.startAngle - this.endAngle + Flatten.PIx2;\n        }\n\n        if (Flatten.Utils.GT(sweep, Flatten.PIx2)) {\n            sweep -= Flatten.PIx2;\n        }\n        if (Flatten.Utils.LT(sweep, 0)) {\n            sweep += Flatten.PIx2;\n        }\n        return sweep;\n    }\n\n    /**\n     * Get start point of arc\n     * @returns {Point}\n     */\n    get start() {\n        let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\n        return p0.rotate(this.startAngle, this.pc);\n    }\n\n    /**\n     * Get end point of arc\n     * @returns {Point}\n     */\n    get end() {\n        let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\n        return p0.rotate(this.endAngle, this.pc);\n    }\n\n    /**\n     * Get center of arc\n     * @returns {Point}\n     */\n    get center() {\n        return this.pc.clone();\n    }\n\n    get vertices() {\n        return [this.start.clone(), this.end.clone()];\n    }\n\n    /**\n     * Get arc length\n     * @returns {number}\n     */\n    get length() {\n        return Math.abs(this.sweep * this.r);\n    }\n\n    /**\n     * Get bounding box of the arc\n     * @returns {Box}\n     */\n    get box() {\n        let func_arcs = this.breakToFunctional();\n        let box = func_arcs.reduce((acc, arc) => acc.merge(arc.start.box), new Flatten.Box());\n        box = box.merge(this.end.box);\n        return box;\n    }\n\n    /**\n     * Returns true if arc contains point, false otherwise\n     * @param {Point} pt - point to test\n     * @returns {boolean}\n     */\n    contains(pt) {\n        // first check if  point on circle (pc,r)\n        if (!Flatten.Utils.EQ(this.pc.distanceTo(pt)[0], this.r))\n            return false;\n\n        // point on circle\n\n        if (pt.equalTo(this.start))\n            return true;\n\n        let angle = new Flatten.Vector(this.pc, pt).slope;\n        let test_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise);\n        return Flatten.Utils.LE(test_arc.length, this.length);\n    }\n\n    /**\n     * When given point belongs to arc, return array of two arcs split by this point. If points is incident\n     * to start or end point of the arc, return clone of the arc. If point does not belong to the arcs, return\n     * empty array.\n     * @param {Point} pt Query point\n     * @returns {Arc[]}\n     */\n    split(pt) {\n        if (this.start.equalTo(pt))\n            return [null, this.clone()];\n\n        if (this.end.equalTo(pt))\n            return [this.clone(), null];\n\n        let angle = new Flatten.Vector(this.pc, pt).slope;\n\n        return [\n            new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise),\n            new Flatten.Arc(this.pc, this.r, angle, this.endAngle, this.counterClockwise)\n        ]\n    }\n\n    /**\n     * Return middle point of the arc\n     * @returns {Point}\n     */\n    middle() {\n        let endAngle = this.counterClockwise ? this.startAngle + this.sweep / 2 : this.startAngle - this.sweep / 2;\n        let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\n        return arc.end;\n    }\n\n    /**\n     * Get point at given length\n     * @param {number} length - The length along the arc\n     * @returns {Point}\n     */\n    pointAtLength(length) {\n        if (length > this.length || length < 0) return null;\n        if (length == 0) return this.start;\n        if (length == this.length) return this.end;\n        let factor = length / this.length;\n        let endAngle = this.counterClockwise ? this.startAngle + this.sweep * factor : this.startAngle - this.sweep * factor;\n        let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\n        return arc.end;\n    }\n\n    /**\n     * Returns chord height (\"sagitta\") of the arc\n     * @returns {number}\n     */\n    chordHeight() {\n        return (1.0 - Math.cos(Math.abs(this.sweep / 2.0))) * this.r;\n    }\n\n    /**\n     * Returns array of intersection points between arc and other shape\n     * @param {Shape} shape Shape of the one of supported types <br/>\n     * @returns {Points[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n        if (shape instanceof Flatten.Line) {\n            return intersectLine2Arc(shape, this);\n        }\n        if (shape instanceof Flatten.Circle) {\n            return intersectArc2Circle(this, shape);\n        }\n        if (shape instanceof Flatten.Segment) {\n            return intersectSegment2Arc(shape, this);\n        }\n        if (shape instanceof Flatten.Box) {\n            return intersectArc2Box(this, shape);\n        }\n        if (shape instanceof Flatten.Arc) {\n            return intersectArc2Arc(this, shape);\n        }\n        if (shape instanceof Flatten.Polygon) {\n            return intersectArc2Polygon(this, shape);\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment from arc to shape and return array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from arc to shape\n     * @returns {Segment} shortest segment between arc and shape (started at arc, ended at shape)\n\n     */\n    distanceTo(shape) {\n        if (shape instanceof Flatten.Point) {\n            let [dist, shortest_segment] = Flatten.Distance.point2arc(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            let [dist, shortest_segment] = Flatten.Distance.arc2circle(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            let [dist, shortest_segment] = Flatten.Distance.arc2line(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2arc(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            let [dist, shortest_segment] = Flatten.Distance.arc2arc(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.PlanarSet) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\n            return [dist, shortest_segment];\n        }\n    }\n\n    /**\n     * Breaks arc in extreme point 0, pi/2, pi, 3*pi/2 and returns array of sub-arcs\n     * @returns {Arcs[]}\n     */\n    breakToFunctional() {\n        let func_arcs_array = [];\n        let angles = [0, Math.PI / 2, 2 * Math.PI / 2, 3 * Math.PI / 2];\n        let pts = [\n            this.pc.translate(this.r, 0),\n            this.pc.translate(0, this.r),\n            this.pc.translate(-this.r, 0),\n            this.pc.translate(0, -this.r)\n        ];\n\n        // If arc contains extreme point,\n        // create test arc started at start point and ended at this extreme point\n        let test_arcs = [];\n        for (let i = 0; i < 4; i++) {\n            if (pts[i].on(this)) {\n                test_arcs.push(new Flatten.Arc(this.pc, this.r, this.startAngle, angles[i], this.counterClockwise));\n            }\n        }\n\n        if (test_arcs.length == 0) {                  // arc does contain any extreme point\n            func_arcs_array.push(this.clone());\n        } else {                                        // arc passes extreme point\n            // sort these arcs by length\n            test_arcs.sort((arc1, arc2) => arc1.length - arc2.length);\n\n            for (let i = 0; i < test_arcs.length; i++) {\n                let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\n                let new_arc;\n                if (prev_arc) {\n                    new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, test_arcs[i].endAngle, this.counterClockwise);\n                } else {\n                    new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, test_arcs[i].endAngle, this.counterClockwise);\n                }\n                if (!Flatten.Utils.EQ_0(new_arc.length)) {\n                    func_arcs_array.push(new_arc.clone());\n                }\n            }\n\n            // add last sub arc\n            let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\n            let new_arc;\n            if (prev_arc) {\n                new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, this.endAngle, this.counterClockwise);\n            } else {\n                new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, this.endAngle, this.counterClockwise);\n            }\n            // It could be 2*PI when occasionally start = 0 and end = 2*PI but this is not valid for breakToFunctional\n            if (!Flatten.Utils.EQ_0(new_arc.length) && !Flatten.Utils.EQ(new_arc.sweep, 2*Math.PI)) {\n                func_arcs_array.push(new_arc.clone());\n            }\n        }\n        return func_arcs_array;\n    }\n\n    /**\n     * Return tangent unit vector in the start point in the direction from start to end\n     * @returns {Vector}\n     */\n    tangentInStart() {\n        let vec = new Flatten.Vector(this.pc, this.start);\n        let angle = this.counterClockwise ? Math.PI / 2. : -Math.PI / 2.;\n        let tangent = vec.rotate(angle).normalize();\n        return tangent;\n    }\n\n    /**\n     * Return tangent unit vector in the end point in the direction from end to start\n     * @returns {Vector}\n     */\n    tangentInEnd() {\n        let vec = new Flatten.Vector(this.pc, this.end);\n        let angle = this.counterClockwise ? -Math.PI / 2. : Math.PI / 2.;\n        let tangent = vec.rotate(angle).normalize();\n        return tangent;\n    }\n\n    /**\n     * Returns new arc with swapped start and end angles and reversed direction\n     * @returns {Arc}\n     */\n    reverse() {\n        return new Flatten.Arc(this.pc, this.r, this.endAngle, this.startAngle, !this.counterClockwise);\n    }\n\n    /**\n     * Returns new arc translated by vector vec\n     * @param {Vector} vec\n     * @returns {Segment}\n     */\n    translate(...args) {\n        let arc = this.clone();\n        arc.pc = this.pc.translate(...args);\n        return arc;\n    }\n\n    /**\n     * Return new segment rotated by given angle around given point\n     * If point omitted, rotate around origin (0,0)\n     * Positive value of angle defines rotation counter clockwise, negative - clockwise\n     * @param {number} angle - rotation angle in radians\n     * @param {Point} center - center point, default is (0,0)\n     * @returns {Arc}\n     */\n    rotate(angle = 0, center = new Flatten.Point()) {\n        let m = new Flatten.Matrix();\n        m = m.translate(center.x, center.y).rotate(angle).translate(-center.x, -center.y);\n        return this.transform(m);\n    }\n\n    /**\n     * Return new arc scaled by scaleX, scaleY.\n     * @param {number} scaleX - scale value by X\n     * @param {number} scaleY - scale value by Y\n     * @returns {Arc}\n     */\n    scale(scaleX = 1, scaleY = 1) {\n        let m = new Flatten.Matrix();\n        m = m.scale(scaleX, scaleY);\n        return this.transform(m);\n    }\n\n    /**\n     * Return new arc transformed using affine transformation matrix <br/>\n     * Note 1. Non-equal scaling by x and y (abs(matrix[0]) != abs(matrix[3])) produce illegal result because\n     * it should create elliptic arc but this package does not support ellipses\n     * Note 2. Mirror transformation (matrix[0] * matrix[3] < 0) change direction of the arc to the opposite\n     * TODO: support non-equal scaling arc to ellipse or throw exception ?\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Arc}\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        let newStart = this.start.transform(matrix);\n        let newEnd = this.end.transform(matrix);\n        let newCenter = this.pc.transform(matrix);\n        let newDirection = this.counterClockwise;\n        if (matrix.a * matrix.d < 0) {\n          newDirection = !newDirection;\n        }\n        let arc = Flatten.Arc.arcSE(newCenter, newStart, newEnd, newDirection);\n        return arc;\n    }\n\n    static arcSE(center, start, end, counterClockwise) {\n        let {vector} = Flatten;\n        let startAngle = vector(center, start).slope;\n        let endAngle = vector(center, end).slope;\n        if (Flatten.Utils.EQ(startAngle, endAngle)) {\n            endAngle += 2 * Math.PI;\n            counterClockwise = true;\n        }\n        let r = vector(center, start).length;\n\n        return new Flatten.Arc(center, r, startAngle, endAngle, counterClockwise);\n    }\n\n    definiteIntegral(ymin = 0) {\n        let f_arcs = this.breakToFunctional();\n        let area = f_arcs.reduce((acc, arc) => acc + arc.circularSegmentDefiniteIntegral(ymin), 0.0);\n        return area;\n    }\n\n    circularSegmentDefiniteIntegral(ymin) {\n        let line = new Flatten.Line(this.start, this.end);\n        let onLeftSide = this.pc.leftTo(line);\n        let segment = new Flatten.Segment(this.start, this.end);\n        let areaTrapez = segment.definiteIntegral(ymin);\n        let areaCircularSegment = this.circularSegmentArea();\n        let area = onLeftSide ? areaTrapez - areaCircularSegment : areaTrapez + areaCircularSegment;\n        return area;\n    }\n\n    circularSegmentArea() {\n        return (0.5 * this.r * this.r * (this.sweep - Math.sin(this.sweep)))\n    }\n\n    /**\n     * Sort given array of points from arc start to end, assuming all points lay on the arc\n     * @param {Point[]} array of points\n     * @returns {Point[]} new array sorted\n     */\n    sortPoints(pts) {\n        let {vector} = Flatten;\n        return pts.slice().sort( (pt1, pt2) => {\n            let slope1 = vector(this.pc, pt1).slope;\n            let slope2 = vector(this.pc, pt2).slope;\n            if (slope1 < slope2) {\n                return -1;\n            }\n            if (slope1 > slope2) {\n                return 1;\n            }\n            return 0;\n        })\n    }\n\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */\n    toJSON() {\n        return Object.assign({}, this, {name: \"arc\"});\n    }\n\n    /**\n     * Return string to draw arc in svg\n     * @param {Object} attrs - an object with attributes of svg path element,\n     * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\n     * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        let largeArcFlag = this.sweep <= Math.PI ? \"0\" : \"1\";\n        let sweepFlag = this.counterClockwise ? \"1\" : \"0\";\n        let {stroke, strokeWidth, fill, id, className} = attrs;\n        // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\n\n        if (Flatten.Utils.EQ(this.sweep, 2 * Math.PI)) {\n            let circle = new Flatten.Circle(this.pc, this.r);\n            return circle.svg(attrs);\n        } else {\n            return `\\n<path d=\"M${this.start.x},${this.start.y}\n                             A${this.r},${this.r} 0 ${largeArcFlag},${sweepFlag} ${this.end.x},${this.end.y}\"\n                    stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" ${id_str} ${class_str} />`\n        }\n    }\n\n}\nFlatten.Arc = Arc;\n/**\n * Function to create arc equivalent to \"new\" constructor\n * @param args\n */\nconst arc = (...args) => new Flatten.Arc(...args);\nFlatten.arc = arc;\n\n/**\n * Created by Alex Bol on 3/7/2017.\n */\n\n/**\n * Class Box represent bounding box of the shape\n * @type {Box}\n */\nclass Box {\n    /**\n     *\n     * @param {number} xmin - minimal x coordinate\n     * @param {number} ymin - minimal y coordinate\n     * @param {number} xmax - maximal x coordinate\n     * @param {number} ymax - maximal y coordinate\n     */\n    constructor(xmin = undefined, ymin = undefined, xmax = undefined, ymax = undefined) {\n        /**\n         * Minimal x coordinate\n         * @type {number}\n         */\n        this.xmin = xmin;\n        /**\n         * Minimal y coordinate\n         * @type {number}\n         */\n        this.ymin = ymin;\n        /**\n         * Maximal x coordinate\n         * @type {number}\n         */\n        this.xmax = xmax;\n        /**\n         * Maximal y coordinate\n         * @type {number}\n         */\n        this.ymax = ymax;\n    }\n\n    /**\n     * Return new cloned instance of box\n     * @returns {Box}\n     */\n    clone() {\n        return new Box(this.xmin, this.ymin, this.xmax, this.ymax);\n    }\n\n    /**\n     * Property low need for interval tree interface\n     * @returns {Point}\n     */\n    get low() {\n        return new Flatten.Point(this.xmin, this.ymin);\n    }\n\n    /**\n     * Property high need for interval tree interface\n     * @returns {Point}\n     */\n    get high() {\n        return new Flatten.Point(this.xmax, this.ymax);\n    }\n\n    /**\n     * Property max returns the box itself !\n     * @returns {Box}\n     */\n    get max() {\n        return this.clone();\n    }\n\n    /**\n     * Return center of the box\n     * @returns {Point}\n     */\n    get center() {\n        return new Flatten.Point((this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2);\n    }\n\n    /**\n     * Return property box like all other shapes\n     * @returns {Box}\n     */\n    get box() {\n        return this.clone();\n    }\n\n    /**\n     * Returns true if not intersected with other box\n     * @param {Box} other_box - other box to test\n     * @returns {boolean}\n     */\n    not_intersect(other_box) {\n        return (\n            this.xmax < other_box.xmin ||\n            this.xmin > other_box.xmax ||\n            this.ymax < other_box.ymin ||\n            this.ymin > other_box.ymax\n        );\n    }\n\n    /**\n     * Returns true if intersected with other box\n     * @param {Box} other_box - Query box\n     * @returns {boolean}\n     */\n    intersect(other_box) {\n        return !this.not_intersect(other_box);\n    }\n\n    /**\n     * Returns new box merged with other box\n     * @param {Box} other_box - Other box to merge with\n     * @returns {Box}\n     */\n    merge(other_box) {\n        return new Box(\n            this.xmin === undefined ? other_box.xmin : Math.min(this.xmin, other_box.xmin),\n            this.ymin === undefined ? other_box.ymin : Math.min(this.ymin, other_box.ymin),\n            this.xmax === undefined ? other_box.xmax : Math.max(this.xmax, other_box.xmax),\n            this.ymax === undefined ? other_box.ymax : Math.max(this.ymax, other_box.ymax)\n        );\n    }\n\n    /**\n     * Defines predicate \"less than\" between two boxes. Need for interval index\n     * @param {Box} other_box - other box\n     * @returns {boolean} - true if this box less than other box, false otherwise\n     */\n    less_than(other_box) {\n        if (this.low.lessThan(other_box.low))\n            return true;\n        if (this.low.equalTo(other_box.low) && this.high.lessThan(other_box.high))\n            return true;\n        return false;\n    }\n\n    /**\n     * Returns true if this box is equal to other box, false otherwise\n     * @param {Box} other_box - query box\n     * @returns {boolean}\n     */\n    equal_to(other_box) {\n        return (this.low.equalTo(other_box.low) && this.high.equalTo(other_box.high));\n    }\n\n    output() {\n        return this.clone();\n    }\n\n    static comparable_max(box1, box2) {\n        // return pt1.lessThan(pt2) ? pt2.clone() : pt1.clone();\n        return box1.merge(box2);\n    }\n\n    static comparable_less_than(pt1, pt2) {\n        return pt1.lessThan(pt2);\n    }\n\n    /**\n     * Set new values to the box object\n     * @param {number} xmin - miminal x coordinate\n     * @param {number} ymin - minimal y coordinate\n     * @param {number} xmax - maximal x coordinate\n     * @param {number} ymax - maximal y coordinate\n     */\n    set(xmin, ymin, xmax, ymax) {\n        this.xmin = xmin;\n        this.ymin = ymin;\n        this.xmax = xmax;\n        this.ymax = ymax;\n    }\n\n    /**\n     * Transform box into array of points from low left corner in counter clockwise\n     * @returns {Point[]}\n     */\n    toPoints() {\n        return [\n            new Flatten.Point(this.xmin, this.ymin),\n            new Flatten.Point(this.xmax, this.ymin),\n            new Flatten.Point(this.xmax, this.ymax),\n            new Flatten.Point(this.xmin, this.ymax)\n        ];\n    }\n\n    /**\n     * Transform box into array of segments from low left corner in counter clockwise\n     * @returns {Segment[]}\n     */\n    toSegments() {\n        let pts = this.toPoints();\n        return [\n            new Flatten.Segment(pts[0], pts[1]),\n            new Flatten.Segment(pts[1], pts[2]),\n            new Flatten.Segment(pts[2], pts[3]),\n            new Flatten.Segment(pts[3], pts[0])\n        ];\n    }\n\n    /**\n     * Return string to draw circle in svg\n     * @param {Object} attrs - an object with attributes of svg rectangle element,\n     * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\n     * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        let {stroke, strokeWidth, fill, id, className} = attrs;\n        // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\n        let width = this.xmax - this.xmin;\n        let height = this.ymax - this.ymin;\n\n        return `\\n<rect x=\"${this.xmin}\" y=\"${this.ymin}\" width=${width} height=${height} stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" ${id_str} ${class_str} />`;\n    };\n}\nFlatten.Box = Box;\n/**\n * Shortcut to create new box\n * @param args\n * @returns {Box}\n */\nconst box = (...args) => new Flatten.Box(...args);\nFlatten.box = box;\n\n/**\n * Created by Alex Bol on 3/17/2017.\n */\n\n/**\n * Class representing an edge of polygon. Edge shape may be Segment or Arc.\n * Each edge contains references to the next and previous edges in the face of the polygon.\n *\n * @type {Edge}\n */\nclass Edge {\n    /**\n     * Construct new instance of edge\n     * @param {Shape} shape Shape of type Segment or Arc\n     */\n    constructor(shape) {\n        /**\n         * Shape of the edge: Segment or Arc\n         * @type {Segment|Arc}\n         */\n        this.shape = shape;\n        /**\n         * Pointer to the next edge in the face\n         * @type {Edge}\n         */\n        this.next = undefined;\n        /**\n         * Pointer to the previous edge in the face\n         * @type {Edge}\n         */\n        this.prev = undefined;\n        /**\n         * Pointer to the face containing this edge\n         * @type {Face}\n         */\n        this.face = undefined;\n        /**\n         * \"Arc distance\" from the face start\n         * @type {number}\n         */\n        this.arc_length = 0;\n        /**\n         * Start inclusion flag (inside/outside/boundary)\n         * @type {*}\n         */\n        this.bvStart = undefined;\n        /**\n         * End inclusion flag (inside/outside/boundary)\n         * @type {*}\n         */\n        this.bvEnd = undefined;\n        /**\n         * Edge inclusion flag (Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY)\n         * @type {*}\n         */\n        this.bv = undefined;\n        /**\n         * Overlap flag for boundary edge (Flatten.OVERLAP_SAME/Flatten.OVERLAP_OPPOSITE)\n         * @type {*}\n         */\n        this.overlap = undefined;\n    }\n\n    /**\n     * Get edge start point\n     */\n    get start() {\n        return this.shape.start;\n    }\n\n    /**\n     * Get edge end point\n     */\n    get end() {\n        return this.shape.end;\n    }\n\n    /**\n     * Get edge length\n     */\n    get length() {\n        return this.shape.length;\n    }\n\n    /**\n     * Get bounding box of the edge\n     * @returns {Box}\n     */\n    get box() {\n        return this.shape.box;\n    }\n\n    isSegment() {\n        return this.shape instanceof Flatten.Segment;\n    }\n\n    isArc() {\n        return this.shape instanceof Flatten.Arc;\n    }\n\n    /**\n     * Get middle point of the edge\n     * @returns {Point}\n     */\n    middle() {\n        return this.shape.middle();\n    }\n\n    /**\n     * Get point at given length\n     * @param {number} length - The length along the edge\n     * @returns {Point}\n     */\n    pointAtLength(length) {\n        return this.shape.pointAtLength(length);\n    }\n\n    /**\n     * Returns true if point belongs to the edge, false otherwise\n     * @param {Point} pt - test point\n     */\n    contains(pt) {\n        return this.shape.contains(pt);\n    }\n\n    /**\n     * Set inclusion flag of the edge with respect to another polygon\n     * Inclusion flag is one of Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY\n     * @param polygon\n     */\n    setInclusion(polygon) {\n        if (this.bv !== undefined) return this.bv;\n\n        if (this.shape instanceof Flatten.Line || this.shape instanceof Flatten.Ray) {\n            this.bv = Flatten.OUTSIDE;\n            return this.bv;\n        }\n\n        if (this.bvStart === undefined) {\n            this.bvStart = ray_shoot(polygon, this.start);\n        }\n        if (this.bvEnd === undefined) {\n            this.bvEnd = ray_shoot(polygon, this.end);\n        }\n        /* At least one end outside - the whole edge outside */\n        if (this.bvStart === Flatten.OUTSIDE || this.bvEnd == Flatten.OUTSIDE) {\n            this.bv = Flatten.OUTSIDE;\n        }\n        /* At least one end inside - the whole edge inside */\n        else if (this.bvStart === Flatten.INSIDE || this.bvEnd == Flatten.INSIDE) {\n            this.bv = Flatten.INSIDE;\n        }\n        /* Both are boundary - check the middle point */\n        else {\n            let bvMiddle = ray_shoot(polygon, this.middle());\n            // let boundary = this.middle().distanceTo(polygon)[0] < 10*Flatten.DP_TOL;\n            // let bvMiddle = boundary ? Flatten.BOUNDARY : ray_shoot(polygon, this.middle());\n            this.bv = bvMiddle;\n        }\n        return this.bv;\n    }\n\n    /**\n     * Set overlapping between two coincident boundary edges\n     * Overlapping flag is one of Flatten.OVERLAP_SAME or Flatten.OVERLAP_OPPOSITE\n     * @param edge\n     */\n    setOverlap(edge) {\n        let flag = undefined;\n        let shape1 = this.shape;\n        let shape2 = edge.shape;\n\n        if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Segment) {\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end)) {\n                flag = Flatten.OVERLAP_SAME;\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start)) {\n                flag = Flatten.OVERLAP_OPPOSITE;\n            }\n        } else if (shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Arc) {\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && /*shape1.counterClockwise === shape2.counterClockwise &&*/\n                shape1.middle().equalTo(shape2.middle())) {\n                flag = Flatten.OVERLAP_SAME;\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && /*shape1.counterClockwise !== shape2.counterClockwise &&*/\n                shape1.middle().equalTo(shape2.middle())) {\n                flag = Flatten.OVERLAP_OPPOSITE;\n            }\n        } else if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Arc ||\n            shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Segment) {\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.middle().equalTo(shape2.middle())) {\n                flag = Flatten.OVERLAP_SAME;\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.middle().equalTo(shape2.middle())) {\n                flag = Flatten.OVERLAP_OPPOSITE;\n            }\n        }\n\n        /* Do not update overlap flag if already set on previous chain */\n        if (this.overlap === undefined) this.overlap = flag;\n        if (edge.overlap === undefined) edge.overlap = flag;\n    }\n\n    svg() {\n        if (this.shape instanceof Flatten.Segment) {\n            return ` L${this.shape.end.x},${this.shape.end.y}`;\n        } else if (this.shape instanceof Flatten.Arc) {\n            let arc = this.shape;\n            let largeArcFlag;\n            let sweepFlag = arc.counterClockwise ? \"1\" : \"0\";\n\n            // Draw full circe arc as special case: split it into two half-circles\n            if (Flatten.Utils.EQ(arc.sweep, 2 * Math.PI)) {\n                let sign = arc.counterClockwise ? 1 : -1;\n                let halfArc1 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle, arc.startAngle + sign * Math.PI, arc.counterClockwise);\n                let halfArc2 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle + sign * Math.PI, arc.endAngle, arc.counterClockwise);\n\n                largeArcFlag = \"0\";\n\n                return ` A${halfArc1.r},${halfArc1.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc1.end.x},${halfArc1.end.y}\n                    A${halfArc2.r},${halfArc2.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc2.end.x},${halfArc2.end.y}`\n            } else {\n                largeArcFlag = arc.sweep <= Math.PI ? \"0\" : \"1\";\n\n                return ` A${arc.r},${arc.r} 0 ${largeArcFlag},${sweepFlag} ${arc.end.x},${arc.end.y}`;\n            }\n        }\n    }\n\n    toJSON() {\n        return this.shape.toJSON();\n    }\n}\nFlatten.Edge = Edge;\n\n/**\n * Class implements circular bidirectional linked list <br/>\n * LinkedListElement - object of any type that has properties next and prev.\n */\nclass CircularLinkedList extends LinkedList {\n    constructor(first, last) {\n        super(first, last);\n        this.setCircularLinks();\n    }\n\n    setCircularLinks() {\n        if (this.isEmpty()) return;\n        this.last.next = this.first;\n        this.first.prev = this.last;\n    }\n\n    [Symbol.iterator]() {\n        let element = undefined;\n        return {\n            next: () => {\n                let value = element ? element : this.first;\n                let done = this.first ? (element ? element === this.first : false) : true;\n                element = value ? value.next : undefined;\n                return {value: value, done: done};\n            }\n        };\n    };\n\n    /**\n     * Append new element to the end of the list\n     * @param {LinkedListElement} element - new element to be appended\n     * @returns {CircularLinkedList}\n     */\n    append(element) {\n        super.append(element);\n        this.setCircularLinks();\n        return this;\n    }\n\n    /**\n     * Insert new element to the list after elementBefore\n     * @param {LinkedListElement} newElement - new element to be inserted\n     * @param {LinkedListElement} elementBefore - element in the list to insert after it\n     * @returns {CircularLinkedList}\n     */\n    insert(newElement, elementBefore) {\n        super.insert(newElement, elementBefore);\n        this.setCircularLinks();\n        return this;\n    }\n\n    /**\n     * Remove element from the list\n     * @param {LinkedListElement} element - element to be removed from the list\n     * @returns {CircularLinkedList}\n     */\n    remove(element) {\n        super.remove(element);\n        // this.setCircularLinks();\n        return this;\n    }\n}\n\n/**\n * Created by Alex Bol on 3/17/2017.\n */\n\n/**\n * Class representing a face (closed loop) in a [polygon]{@link Flatten.Polygon} object.\n * Face is a circular bidirectional linked list of [edges]{@link Flatten.Edge}.\n * Face object cannot be instantiated with a constructor.\n * Instead, use [polygon.addFace()]{@link Flatten.Polygon#addFace} method.\n * <br/>\n * Note, that face only set entry point to the linked list of edges but does not contain edges by itself.\n * Container of edges is a property of the polygon object. <br/>\n *\n * @example\n * // Face implements \"next\" iterator which enables to iterate edges in for loop:\n * for (let edge of face) {\n *      console.log(edge.shape.length)     // do something\n * }\n *\n * // Instead, it is possible to iterate edges as linked list, starting from face.first:\n * let edge = face.first;\n * do {\n *   console.log(edge.shape.length);   // do something\n *   edge = edge.next;\n * } while (edge != face.first)\n */\nclass Face extends CircularLinkedList {\n    constructor(polygon, ...args) {\n        super();            // construct empty list of edges\n        /**\n         * Reference to the first edge in face\n         */\n        // this.first;\n        /**\n         * Reference to the last edge in face\n         */\n        // this.last;\n\n        this._box = undefined;  // new Box();\n        this._orientation = undefined;\n\n        if (args.length == 0) {\n            return;\n        }\n\n        /* If passed an array it supposed to be:\n         1) array of shapes that performs close loop or\n         2) array of points that performs set of vertices\n         */\n        if (args.length == 1) {\n            if (args[0] instanceof Array) {\n                // let argsArray = args[0];\n                let shapes = args[0];  // argsArray[0];\n                if (shapes.length == 0)\n                    return;\n\n                /* array of Flatten.Points */\n                if (shapes.every((shape) => {return shape instanceof Flatten.Point})) {\n                    let segments = Face.points2segments(shapes);\n                    this.shapes2face(polygon.edges, segments);\n                }\n                /* array of points as pairs of numbers */\n                else if (shapes.every((shape) => {return shape instanceof Array && shape.length === 2})) {\n                    let points = shapes.map((shape) => new Flatten.Point(shape[0],shape[1]));\n                    let segments = Face.points2segments(points);\n                    this.shapes2face(polygon.edges, segments);\n                }\n                /* array of segments ot arcs */\n                else if (shapes.every((shape) => {\n                    return (shape instanceof Flatten.Segment || shape instanceof Flatten.Arc)\n                })) {\n                    this.shapes2face(polygon.edges, shapes);\n                }\n                // this is from JSON.parse object\n                else if (shapes.every((shape) => {\n                    return (shape.name === \"segment\" || shape.name === \"arc\")\n                })) {\n                    let flattenShapes = [];\n                    for (let shape of shapes) {\n                        let flattenShape;\n                        if (shape.name === \"segment\") {\n                            flattenShape = new Flatten.Segment(shape);\n                        } else {\n                            flattenShape = new Flatten.Arc(shape);\n                        }\n                        flattenShapes.push(flattenShape);\n                    }\n                    this.shapes2face(polygon.edges, flattenShapes);\n                }\n            }\n            /* Create new face and copy edges into polygon.edges set */\n            else if (args[0] instanceof Face) {\n                let face = args[0];\n                this.first = face.first;\n                this.last = face.last;\n                for (let edge of face) {\n                    polygon.edges.add(edge);\n                }\n            }\n            /* Instantiate face from a circle in CCW orientation */\n            else if (args[0] instanceof Flatten.Circle) {\n                this.shapes2face(polygon.edges, [args[0].toArc(Flatten.CCW)]);\n            }\n            /* Instantiate face from a box in CCW orientation */\n            else if (args[0] instanceof Flatten.Box) {\n                let box = args[0];\n                this.shapes2face(polygon.edges, [\n                    new Flatten.Segment(new Flatten.Point(box.xmin, box.ymin), new Flatten.Point(box.xmax, box.ymin)),\n                    new Flatten.Segment(new Flatten.Point(box.xmax, box.ymin), new Flatten.Point(box.xmax, box.ymax)),\n                    new Flatten.Segment(new Flatten.Point(box.xmax, box.ymax), new Flatten.Point(box.xmin, box.ymax)),\n                    new Flatten.Segment(new Flatten.Point(box.xmin, box.ymax), new Flatten.Point(box.xmin, box.ymin))\n                ]);\n            }\n        }\n        /* If passed two edges, consider them as start and end of the face loop */\n        /* THIS METHOD WILL BE USED BY BOOLEAN OPERATIONS */\n        /* Assume that edges already copied to polygon.edges set in the clip algorithm !!! */\n        if (args.length == 2 && args[0] instanceof Flatten.Edge && args[1] instanceof Flatten.Edge) {\n            this.first = args[0];                          // first edge in face or undefined\n            this.last = args[1];                           // last edge in face or undefined\n            this.last.next = this.first;\n            this.first.prev = this.last;\n\n            // set arc length\n            this.setArcLength();\n\n            // this.box = this.getBox();\n            // this.orientation = this.getOrientation();      // face direction cw or ccw\n        }\n    }\n\n    /**\n     * Return array of edges from first to last\n     * @returns {Array}\n     */\n    get edges() {\n        return this.toArray();\n    }\n\n    /**\n     * Return array of shapes which comprise face\n     * @returns {Array}\n     */\n    get shapes() {\n        return this.edges.map(edge => edge.shape.clone());\n    }\n\n    /**\n     * Return bounding box of the face\n     * @returns {Box}\n     */\n    get box() {\n        if (this._box === undefined) {\n            let box = new Flatten.Box();\n            for (let edge of this) {\n                box = box.merge(edge.box);\n            }\n            this._box = box;\n        }\n        return this._box;\n    }\n\n    /**\n     * Get all edges length\n     * @returns {number}\n     */\n    get perimeter() {\n        return this.last.arc_length + this.last.length\n    }\n\n    /**\n     * Get point on face boundary at given length\n     * @param {number} length - The length along the face boundary\n     * @returns {Point}\n     */\n    pointAtLength(length) {\n        if (length > this.perimeter || length < 0) return null;\n        let point = null;\n        for (let edge of this) {\n            if (length >= edge.arc_length &&\n                (edge === this.last || length < edge.next.arc_length)) {\n                point = edge.pointAtLength(length - edge.arc_length);\n                break;\n            }\n        }\n        return point;\n    }\n\n    static points2segments(points) {\n        let segments = [];\n        for (let i = 0; i < points.length; i++) {\n            // skip zero length segment\n            if (points[i].equalTo(points[(i + 1) % points.length]))\n                continue;\n            segments.push(new Flatten.Segment(points[i], points[(i + 1) % points.length]));\n        }\n        return segments;\n    }\n\n    shapes2face(edges, shapes) {\n        for (let shape of shapes) {\n            let edge = new Flatten.Edge(shape);\n            this.append(edge);\n            // this.box = this.box.merge(shape.box);\n            edges.add(edge);\n        }\n        // this.orientation = this.getOrientation();              // face direction cw or ccw\n    }\n\n    /**\n     * Append edge after the last edge of the face (and before the first edge). <br/>\n     * @param {Edge} edge - Edge to be appended to the linked list\n     * @returns {Face}\n     */\n    append(edge) {\n        super.append(edge);\n        // set arc length\n        this.setOneEdgeArcLength(edge);\n        edge.face = this;\n        // edges.add(edge);      // Add new edges into edges container\n        return this;\n    }\n\n    /**\n     * Insert edge newEdge into the linked list after the edge edgeBefore <br/>\n     * @param {Edge} newEdge - Edge to be inserted into linked list\n     * @param {Edge} edgeBefore - Edge to insert newEdge after it\n     * @returns {Face}\n     */\n    insert(newEdge, edgeBefore) {\n        super.insert(newEdge, edgeBefore);\n        // set arc length\n        this.setOneEdgeArcLength(newEdge);\n        newEdge.face = this;\n        return this;\n    }\n\n    /**\n     * Remove the given edge from the linked list of the face <br/>\n     * @param {Edge} edge - Edge to be removed\n     * @returns {Face}\n     */\n    remove(edge) {\n        super.remove(edge);\n        // Recalculate arc length\n        this.setArcLength();\n        return this;\n    }\n\n    /**\n     * Reverse orientation of the face: first edge become last and vice a verse,\n     * all edges starts and ends swapped, direction of arcs inverted. If face was oriented\n     * clockwise, it becomes counter clockwise and vice versa\n     */\n    reverse() {\n        // collect edges in revert order with reverted shapes\n        let edges = [];\n        let edge_tmp = this.last;\n        do {\n            // reverse shape\n            edge_tmp.shape = edge_tmp.shape.reverse();\n            edges.push(edge_tmp);\n            edge_tmp = edge_tmp.prev;\n        } while (edge_tmp !== this.last);\n\n        // restore linked list\n        this.first = undefined;\n        this.last = undefined;\n        for (let edge of edges) {\n            if (this.first === undefined) {\n                edge.prev = edge;\n                edge.next = edge;\n                this.first = edge;\n                this.last = edge;\n            } else {\n                // append to end\n                edge.prev = this.last;\n                this.last.next = edge;\n\n                // update edge to be last\n                this.last = edge;\n\n                // restore circular links\n                this.last.next = this.first;\n                this.first.prev = this.last;\n\n            }\n            // set arc length\n            this.setOneEdgeArcLength(edge);\n        }\n\n        // Recalculate orientation, if set\n        if (this._orientation !== undefined) {\n            this._orientation = undefined;\n            this._orientation = this.orientation();\n        }\n    }\n\n\n    /**\n     * Set arc_length property for each of the edges in the face.\n     * Arc_length of the edge it the arc length from the first edge of the face\n     */\n    setArcLength() {\n        for (let edge of this) {\n            this.setOneEdgeArcLength(edge);\n            edge.face = this;\n        }\n    }\n\n    setOneEdgeArcLength(edge) {\n        if (edge === this.first) {\n            edge.arc_length = 0.0;\n        } else {\n            edge.arc_length = edge.prev.arc_length + edge.prev.length;\n        }\n    }\n\n    /**\n     * Returns the absolute value of the area of the face\n     * @returns {number}\n     */\n    area() {\n        return Math.abs(this.signedArea());\n    }\n\n    /**\n     * Returns signed area of the simple face.\n     * Face is simple if it has no self intersections that change its orientation.\n     * Then the area will be positive if the orientation of the face is clockwise,\n     * and negative if orientation is counterclockwise.\n     * It may be zero if polygon is degenerated.\n     * @returns {number}\n     */\n    signedArea() {\n        let sArea = 0;\n        let ymin = this.box.ymin;\n        for (let edge of this) {\n            sArea += edge.shape.definiteIntegral(ymin);\n        }\n        return sArea;\n    }\n\n    /**\n     * Return face orientation: one of Flatten.ORIENTATION.CCW, Flatten.ORIENTATION.CW, Flatten.ORIENTATION.NOT_ORIENTABLE <br/>\n     * According to Green theorem the area of a closed curve may be calculated as double integral,\n     * and the sign of the integral will be defined by the direction of the curve.\n     * When the integral (\"signed area\") will be negative, direction is counter clockwise,\n     * when positive - clockwise and when it is zero, polygon is not orientable.\n     * See {@link https://mathinsight.org/greens_theorem_find_area}\n     * @returns {number}\n     */\n    orientation() {\n        if (this._orientation === undefined) {\n            let area = this.signedArea();\n            if (Flatten.Utils.EQ_0(area)) {\n                this._orientation = Flatten.ORIENTATION.NOT_ORIENTABLE;\n            } else if (Flatten.Utils.LT(area, 0)) {\n                this._orientation = Flatten.ORIENTATION.CCW;\n            } else {\n                this._orientation = Flatten.ORIENTATION.CW;\n            }\n        }\n        return this._orientation;\n    }\n\n    /**\n     * Returns true if face of the polygon is simple (no self-intersection points found)\n     * NOTE: this method is incomplete because it does not exclude touching points.\n     * Self intersection test should check if polygon change orientation in the test point.\n     * @param {Edges} edges - reference to polygon.edges to provide search index\n     * @returns {boolean}\n     */\n    isSimple(edges) {\n        let ip = Face.getSelfIntersections(this, edges, true);\n        return ip.length == 0;\n    }\n\n    static getSelfIntersections(face, edges, exitOnFirst = false) {\n        let int_points = [];\n\n        // calculate intersections\n        for (let edge1 of face) {\n\n            // request edges of polygon in the box of edge1\n            let resp = edges.search(edge1.box);\n\n            // for each edge2 in response\n            for (let edge2 of resp) {\n\n                // Skip itself\n                if (edge1 === edge2)\n                    continue;\n\n                // Skip is edge2 belongs to another face\n                if (edge2.face !== face)\n                    continue;\n\n                // Skip next and previous edge if both are segment (if one of them arc - calc intersection)\n                if (edge1.shape instanceof Flatten.Segment && edge2.shape instanceof Flatten.Segment &&\n                    (edge1.next === edge2 || edge1.prev === edge2))\n                    continue;\n\n                // calculate intersections between edge1 and edge2\n                let ip = edge1.shape.intersect(edge2.shape);\n\n                // for each intersection point\n                for (let pt of ip) {\n\n                    // skip start-end connections\n                    if (pt.equalTo(edge1.start) && pt.equalTo(edge2.end) && edge2 === edge1.prev)\n                        continue;\n                    if (pt.equalTo(edge1.end) && pt.equalTo(edge2.start) && edge2 === edge1.next)\n                        continue;\n\n                    int_points.push(pt);\n\n                    if (exitOnFirst)\n                        break;\n                }\n\n                if (int_points.length > 0 && exitOnFirst)\n                    break;\n            }\n\n            if (int_points.length > 0 && exitOnFirst)\n                break;\n\n        }\n        return int_points;\n    }\n\n    /**\n     * Returns edge which contains given point\n     * @param {Point} pt - test point\n     * @returns {Edge}\n     */\n    findEdgeByPoint(pt) {\n        let edgeFound;\n        for (let edge of this) {\n            if (edge.shape.contains(pt)) {\n                edgeFound = edge;\n                break;\n            }\n        }\n        return edgeFound;\n    }\n\n    /**\n     * Returns new polygon created from one face\n     * @returns {Polygon}\n     */\n    toPolygon() {\n        return new Flatten.Polygon(this.shapes);\n    }\n\n    toJSON() {\n        return this.edges.map(edge => edge.toJSON());\n    }\n\n    /**\n     * Returns string to be assigned to \"d\" attribute inside defined \"path\"\n     * @returns {string}\n     */\n    svg() {\n        let svgStr = `\\nM${this.first.start.x},${this.first.start.y}`;\n        for (let edge of this) {\n            svgStr += edge.svg();\n        }\n        svgStr += ` z`;\n        return svgStr;\n    }\n\n}\nFlatten.Face = Face;\n\n/**\n * Class representing a ray (a half-infinite line).\n * @type {Ray}\n */\nclass Ray {\n    /**\n     * Ray may be constructed by setting an <b>origin</b> point and a <b>normal</b> vector, so that any point <b>x</b>\n     * on a ray fit an equation: <br />\n     *  (<b>x</b> - <b>origin</b>) * <b>vector</b> = 0 <br />\n     * Ray defined by constructor is a right semi-infinite line with respect to the normal vector <br/>\n     * If normal vector is omitted ray is considered horizontal (normal vector is (0,1)). <br/>\n     * Don't be confused: direction of the normal vector is orthogonal to the ray <br/>\n     * @param {Point} pt - start point\n     * @param {Vector} norm - normal vector\n     */\n    constructor(...args) {\n        this.pt = new Flatten.Point();\n        this.norm = new Flatten.Vector(0,1);\n\n        if (args.length == 0) {\n            return;\n        }\n\n        if (args.length >= 1 && args[0] instanceof Flatten.Point) {\n            this.pt = args[0].clone();\n        }\n\n        if (args.length === 1) {\n            return;\n        }\n\n        if (args.length === 2 && args[1] instanceof Flatten.Vector) {\n            this.norm = args[1].clone();\n            return;\n        }\n\n        // if (args.length == 2 && typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\n        //     this.pt = new Flatten.Point(args[0], args[1]);\n        //     return;\n        // }\n\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Return new cloned instance of ray\n     * @returns {Ray}\n     */\n    clone() {\n        return new Ray(this.pt, this.norm);\n    }\n\n    /**\n     * Slope of the ray - angle in radians between ray and axe x from 0 to 2PI\n     * @returns {number} - slope of the line\n     */\n    get slope() {\n        let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\n        return vec.slope;\n    }\n\n    /**\n     * Returns half-infinite bounding box of the ray\n     * @returns {Box} - bounding box\n     */\n    get box() {\n        let slope = this.slope;\n        return new Flatten.Box(\n            slope > Math.PI/2 && slope < 3*Math.PI/2 ? Number.NEGATIVE_INFINITY : this.pt.x,\n            slope >= 0 && slope <= Math.PI ? this.pt.y : Number.NEGATIVE_INFINITY,\n            slope >= Math.PI/2 && slope <= 3*Math.PI/2 ? this.pt.x : Number.POSITIVE_INFINITY,\n            slope >= Math.PI && slope <= 2*Math.PI || slope == 0 ? this.pt.y : Number.POSITIVE_INFINITY\n        )\n    }\n\n    /**\n     * Return ray start point\n     * @returns {Point} - ray start point\n     */\n    get start() {\n        return this.pt;\n    }\n\n    /**\n     * Ray has no end point?\n     * @returns {undefined}\n     */\n    get end() {return undefined;}\n\n    /**\n     * Return positive infinity number as length\n     * @returns {number}\n     */\n    get length() {return Number.POSITIVE_INFINITY;}\n\n    /**\n     * Returns true if point belongs to ray\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    contains(pt) {\n        if (this.pt.equalTo(pt)) {\n            return true;\n        }\n        /* Ray contains point if vector to point is orthogonal to the ray normal vector\n            and cross product from vector to point is positive */\n        let vec = new Flatten.Vector(this.pt, pt);\n        return Flatten.Utils.EQ_0(this.norm.dot(vec)) && Flatten.Utils.GE(vec.cross(this.norm),0);\n    }\n\n    /**\n     * Split ray with point and return array of segment and new ray\n     * @param {Point} pt\n     * @returns [Segment,Ray]\n     */\n    split(pt) {\n        if (!this.contains(pt))\n            return [];\n\n        if (this.pt.equalTo(pt)) {\n            return [this]\n        }\n\n        return [\n            new Flatten.Segment(this.pt, pt),\n            new Flatten.Ray(pt, this.norm)\n        ]\n    }\n\n    /**\n     * Returns array of intersection points between ray and segment or arc\n     * @param {Segment|Arc} - Shape to intersect with ray\n     * @returns {Array} array of intersection points\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Segment) {\n            return this.intersectRay2Segment(this, shape);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return this.intersectRay2Arc(this, shape);\n        }\n    }\n\n    intersectRay2Segment(ray, segment) {\n        let ip = [];\n\n        // if (ray.box.not_intersect(segment.box)) {\n        //     return ip;\n        // }\n\n        let line = new Flatten.Line(ray.start, ray.norm);\n        let ip_tmp = line.intersect(segment);\n\n        for (let pt of ip_tmp) {\n            // if (Flatten.Utils.GE(pt.x, ray.start.x)) {\n            if (ray.contains(pt)) {\n                ip.push(pt);\n            }\n        }\n\n        /* If there were two intersection points between line and ray,\n        and now there is exactly one left, it means ray starts between these points\n        and there is another intersection point - start of the ray */\n        if (ip_tmp.length == 2 && ip.length == 1 && ray.start.on(line)) {\n            ip.push(ray.start);\n        }\n\n        return ip;\n    }\n\n    intersectRay2Arc(ray, arc) {\n        let ip = [];\n\n        // if (ray.box.not_intersect(arc.box)) {\n        //     return ip;\n        // }\n\n        let line = new Flatten.Line(ray.start, ray.norm);\n        let ip_tmp = line.intersect(arc);\n\n        for (let pt of ip_tmp) {\n            // if (Flatten.Utils.GE(pt.x, ray.start.x)) {\n            if (ray.contains(pt)) {\n                ip.push(pt);\n            }\n        }\n        return ip;\n    }\n\n    /**\n     * Return string to draw svg segment representing ray inside given box\n     * @param {Box} box Box representing drawing area\n     * @param {Object} attrs - an object with attributes of svg segment element\n     */\n    svg(box, attrs = {}) {\n        let line = new Flatten.Line(this.pt, this.norm);\n        let ip = intersectLine2Box(line, box);\n        ip = ip.filter( pt => this.contains(pt) );\n        if (ip.length === 0 || ip.length === 2)\n            return \"\";\n        let segment = new Flatten.Segment(this.pt, ip[0]);\n        return segment.svg(attrs);\n    }\n\n}\nFlatten.Ray = Ray;\n\nconst ray = (...args) => new Flatten.Ray(...args);\nFlatten.ray = ray;\n\n/**\n * Created by Alex Bol on 3/15/2017.\n */\n\n/**\n * Class representing a polygon.<br/>\n * Polygon in FlattenJS is a multipolygon comprised from a set of [faces]{@link Flatten.Face}. <br/>\n * Face, in turn, is a closed loop of [edges]{@link Flatten.Edge}, where edge may be segment or circular arc<br/>\n * @type {Polygon}\n */\nclass Polygon {\n    /**\n     * Constructor creates new instance of polygon. With no arguments new polygon is empty.<br/>\n     * Constructor accepts as argument array that define loop of shapes\n     * or array of arrays in case of multi polygon <br/>\n     * Loop may be defined in different ways: <br/>\n     * - array of shapes of type Segment or Arc <br/>\n     * - array of points (Flatten.Point) <br/>\n     * - array of numeric pairs which represent points <br/>\n     * - box or circle object <br/>\n     * Alternatively, it is possible to use polygon.addFace method\n     * @param {args} - array of shapes or array of arrays\n     */\n    constructor() {\n        /**\n         * Container of faces (closed loops), may be empty\n         * @type {PlanarSet}\n         */\n        this.faces = new Flatten.PlanarSet();\n        /**\n         * Container of edges\n         * @type {PlanarSet}\n         */\n        this.edges = new Flatten.PlanarSet();\n\n        /* It may be array of something that may represent one loop (face) or\n         array of arrays that represent multiple loops\n         */\n        let args = [...arguments];\n        if (args.length === 1 &&\n            ((args[0] instanceof Array && args[0].length > 0) ||\n                args[0] instanceof Flatten.Circle || args[0] instanceof Flatten.Box)) {\n            let argsArray = args[0];\n            if (args[0] instanceof Array && args[0].every((loop) => {return loop instanceof Array})) {\n                if  (argsArray.every( el => {return el instanceof Array && el.length === 2 && typeof(el[0]) === \"number\" && typeof(el[1]) === \"number\"} )) {\n                    this.faces.add(new Flatten.Face(this, argsArray));    // one-loop polygon as array of pairs of numbers\n                }\n                else {\n                    for (let loop of argsArray) {   // multi-loop polygon\n                        /* Check extra level of nesting for GeoJSON-style multi polygons */\n                        if (loop instanceof Array && loop[0] instanceof Array &&\n                            loop[0].every( el => {return el instanceof Array && el.length === 2 && typeof(el[0]) === \"number\" && typeof(el[1]) === \"number\"} )) {\n                            for (let loop1 of loop) {\n                                this.faces.add(new Flatten.Face(this, loop1));\n                            }\n                        }\n                        else {\n                            this.faces.add(new Flatten.Face(this, loop));\n                        }\n                    }\n                }\n            }\n            else {\n                this.faces.add(new Flatten.Face(this, argsArray));    // one-loop polygon\n            }\n        }\n    }\n\n    /**\n     * (Getter) Returns bounding box of the polygon\n     * @returns {Box}\n     */\n    get box() {\n        return [...this.faces].reduce((acc, face) => acc.merge(face.box), new Flatten.Box());\n    }\n\n    /**\n     * (Getter) Returns array of vertices\n     * @returns {Array}\n     */\n    get vertices() {\n        return [...this.edges].map(edge => edge.start);\n    }\n\n    /**\n     * Create new cloned instance of the polygon\n     * @returns {Polygon}\n     */\n    clone() {\n        let polygon = new Polygon();\n        for (let face of this.faces) {\n            polygon.addFace(face.shapes);\n        }\n        return polygon;\n    }\n\n    /**\n     * Return true is polygon has no edges\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return this.edges.size === 0;\n    }\n\n    /**\n     * Return true if polygon is valid for boolean operations\n     * Polygon is valid if <br/>\n     * 1. All faces are simple polygons (there are no self-intersected polygons) <br/>\n     * 2. All faces are orientable and there is no island inside island or hole inside hole - TODO <br/>\n     * 3. There is no intersections between faces (excluding touching) - TODO <br/>\n     * @returns {boolean}\n     */\n    isValid() {\n        let valid = true;\n        // 1. Polygon is invalid if at least one face is not simple\n        for (let face of this.faces) {\n            if (!face.isSimple(this.edges)) {\n                valid = false;\n                break;\n            }\n        }\n        // 2. TODO: check if no island inside island and no hole inside hole\n        // 3. TODO: check the there is no intersection between faces\n        return valid;\n    }\n\n    /**\n     * Returns area of the polygon. Area of an island will be added, area of a hole will be subtracted\n     * @returns {number}\n     */\n    area() {\n        let signedArea = [...this.faces].reduce((acc, face) => acc + face.signedArea(), 0);\n        return Math.abs(signedArea);\n    }\n\n    /**\n     * Add new face to polygon. Returns added face\n     * @param {Points[]|Segments[]|Arcs[]|Circle|Box} args -  new face may be create with one of the following ways: <br/>\n     * 1) array of points that describe closed path (edges are segments) <br/>\n     * 2) array of shapes (segments and arcs) which describe closed path <br/>\n     * 3) circle - will be added as counterclockwise arc <br/>\n     * 4) box - will be added as counterclockwise rectangle <br/>\n     * You can chain method face.reverse() is you need to change direction of the creates face\n     * @returns {Face}\n     */\n    addFace(...args) {\n        let face = new Flatten.Face(this, ...args);\n        this.faces.add(face);\n        return face;\n    }\n\n    /**\n     * Delete existing face from polygon\n     * @param {Face} face Face to be deleted\n     * @returns {boolean}\n     */\n    deleteFace(face) {\n        for (let edge of face) {\n            let deleted = this.edges.delete(edge);\n        }\n        let deleted = this.faces.delete(face);\n        return deleted;\n    }\n\n    /**\n     * Delete chain of edges from the face.\n     * @param {Face} face Face to remove chain\n     * @param {Edge} edgeFrom Start of the chain of edges to be removed\n     * @param {Edge} edgeTo End of the chain of edges to be removed\n     */\n    removeChain(face, edgeFrom, edgeTo) {\n        // Special case: all edges removed\n        if (edgeTo.next === edgeFrom) {\n            this.deleteFace(face);\n            return;\n        }\n        for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next) {\n            face.remove(edge);\n            this.edges.delete(edge);      // delete from PlanarSet of edges and update index\n            if (face.isEmpty()) {\n                this.deleteFace(face);    // delete from PlanarSet of faces and update index\n                break;\n            }\n        }\n    }\n\n    /**\n     * Add point as a new vertex and split edge. Point supposed to belong to an edge.\n     * When edge is split, new edge created from the start of the edge to the new vertex\n     * and inserted before current edge.\n     * Current edge is trimmed and updated.\n     * Method returns new edge added. If no edge added, it returns edge before vertex\n     * @param {Point} pt Point to be added as a new vertex\n     * @param {Edge} edge Edge to be split with new vertex and then trimmed from start\n     * @returns {Edge}\n     */\n    addVertex(pt, edge) {\n        let shapes = edge.shape.split(pt);\n        // if (shapes.length < 2) return;\n\n        if (shapes[0] === null)   // point incident to edge start vertex, return previous edge\n            return edge.prev;\n\n        if (shapes[1] === null)   // point incident to edge end vertex, return edge itself\n            return edge;\n\n        let newEdge = new Flatten.Edge(shapes[0]);\n        let edgeBefore = edge.prev;\n\n        /* Insert first split edge into linked list after edgeBefore */\n        edge.face.insert(newEdge, edgeBefore);\n\n        // Remove old edge from edges container and 2d index\n        this.edges.delete(edge);\n\n        // Insert new edge to the edges container and 2d index\n        this.edges.add(newEdge);\n\n        // Update edge shape with second split edge keeping links\n        edge.shape = shapes[1];\n\n        // Add updated edge to the edges container and 2d index\n        this.edges.add(edge);\n\n        return newEdge;\n    }\n\n    /**\n     * Cut polygon with multiline and return array of new polygons\n     * Multiline should be constructed from a line with intersection point, see notebook:\n     * https://next.observablehq.com/@alexbol99/cut-polygon-with-line\n     * @param {Multiline} multiline\n     * @returns {Polygon[]}\n     */\n    cut(multiline) {\n        let cutPolygons = [this.clone()];\n        for (let edge of multiline) {\n            if (edge.setInclusion(this) !== Flatten.INSIDE)\n                continue;\n\n            let cut_edge_start = edge.shape.start;\n            let cut_edge_end = edge.shape.end;\n\n            let newCutPolygons = [];\n            for (let polygon of cutPolygons) {\n                if (polygon.findEdgeByPoint(cut_edge_start) === undefined) {\n                    newCutPolygons.push(polygon);\n                }\n                else {\n                    let [cutPoly1, cutPoly2] = polygon.cutFace(cut_edge_start, cut_edge_end);\n                    newCutPolygons.push(cutPoly1, cutPoly2);\n                }\n            }\n            cutPolygons = newCutPolygons;\n        }\n        return cutPolygons;\n    }\n\n    /**\n     * Cut face of polygon with a segment between two points and create two new polygons\n     * Supposed that a segments between points does not intersect any other edge\n     * @param {Point} pt1\n     * @param {Point} pt2\n     * @returns {Polygon[]}\n     */\n    cutFace(pt1, pt2) {\n        let edge1 = this.findEdgeByPoint(pt1);\n        let edge2 = this.findEdgeByPoint(pt2);\n        if (edge1.face != edge2.face) return;\n\n        // Cut face into two and create new polygon with two faces\n        let edgeBefore1 = this.addVertex(pt1, edge1);\n        edge2 = this.findEdgeByPoint(pt2);\n        let edgeBefore2 = this.addVertex(pt2, edge2);\n\n        let face = edgeBefore1.face;\n        let newEdge1 = new Flatten.Edge(\n            new Flatten.Segment(edgeBefore1.end, edgeBefore2.end)\n        );\n        let newEdge2 = new Flatten.Edge(\n            new Flatten.Segment(edgeBefore2.end, edgeBefore1.end)\n        );\n\n        // Swap links\n        edgeBefore1.next.prev = newEdge2;\n        newEdge2.next = edgeBefore1.next;\n\n        edgeBefore1.next = newEdge1;\n        newEdge1.prev = edgeBefore1;\n\n        edgeBefore2.next.prev = newEdge1;\n        newEdge1.next = edgeBefore2.next;\n\n        edgeBefore2.next = newEdge2;\n        newEdge2.prev = edgeBefore2;\n\n        // Insert new edge to the edges container and 2d index\n        this.edges.add(newEdge1);\n        this.edges.add(newEdge2);\n\n        // Add two new faces\n        let face1 = this.addFace(newEdge1, edgeBefore1);\n        let face2 = this.addFace(newEdge2, edgeBefore2);\n\n        // Remove old face\n        this.faces.delete(face);\n\n        return [face1.toPolygon(), face2.toPolygon()];\n    }\n\n    /**\n     * Returns the first founded edge of polygon that contains given point\n     * @param {Point} pt\n     * @returns {Edge}\n     */\n    findEdgeByPoint(pt) {\n        let edge;\n        for (let face of this.faces) {\n            edge = face.findEdgeByPoint(pt);\n            if (edge != undefined)\n                break;\n        }\n        return edge;\n    }\n\n    /**\n     * Split polygon into array of polygons, where each polygon is an island with all\n     * hole that it contains\n     * @returns {Flatten.Polygon[]}\n     */\n    splitToIslands() {\n        let polygons = this.toArray();      // split into array of one-loop polygons\n        /* Sort polygons by area in descending order */\n        polygons.sort( (polygon1, polygon2) => polygon2.area() - polygon1.area() );\n        /* define orientation of the island by orientation of the first polygon in array */\n        let orientation = [...polygons[0].faces][0].orientation();\n        /* Create output array from polygons with same orientation as a first polygon (array of islands) */\n        let newPolygons = polygons.filter( polygon => [...polygon.faces][0].orientation() === orientation);\n        for (let polygon of polygons) {\n            let face = [...polygon.faces][0];\n            if (face.orientation() === orientation) continue;  // skip same orientation\n            /* Proceed with opposite orientation */\n            /* Look if any of island polygons contains tested polygon as a hole */\n            for (let islandPolygon of newPolygons) {\n                if (face.shapes.every(shape => islandPolygon.contains(shape))) {\n                    islandPolygon.addFace(face.shapes);      // add polygon as a hole in islandPolygon\n                    break;\n                }\n            }\n        }\n        // TODO: assert if not all polygons added into output\n        return newPolygons;\n    }\n\n    /**\n     * Reverse orientation of all faces to opposite\n     * @returns {Polygon}\n     */\n    reverse() {\n        for (let face of this.faces) {\n            face.reverse();\n        }\n        return this;\n    }\n\n    /**\n     * Returns true if polygon contains shape: no point of shape lay outside of the polygon,\n     * false otherwise\n     * @param {Shape} shape - test shape\n     * @returns {boolean}\n     */\n    contains(shape) {\n        if (shape instanceof Flatten.Point) {\n            let rel = ray_shoot(this, shape);\n            return rel === Flatten.INSIDE || rel === Flatten.BOUNDARY;\n        }\n        else {\n            return cover(this, shape);\n        }\n    }\n\n    /**\n     * Return distance and shortest segment between polygon and other shape as array [distance, shortest_segment]\n     * @param {Shape} shape Shape of one of the types Point, Circle, Line, Segment, Arc or Polygon\n     * @returns {Number | Segment}\n     */\n    distanceTo(shape) {\n        // let {Distance} = Flatten;\n\n        if (shape instanceof Flatten.Point) {\n            let [dist, shortest_segment] = Flatten.Distance.point2polygon(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle ||\n            shape instanceof Flatten.Line ||\n            shape instanceof Flatten.Segment ||\n            shape instanceof Flatten.Arc) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        /* this method is bit faster */\n        if (shape instanceof Flatten.Polygon) {\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n            let dist, shortest_segment;\n\n            for (let edge of this.edges) {\n                // let [dist, shortest_segment] = Distance.shape2polygon(edge.shape, shape);\n                let min_stop = min_dist_and_segment[0];\n                [dist, shortest_segment] = Flatten.Distance.shape2planarSet(edge.shape, shape.edges, min_stop);\n                if (Flatten.Utils.LT(dist, min_stop)) {\n                    min_dist_and_segment = [dist, shortest_segment];\n                }\n            }\n            return min_dist_and_segment;\n        }\n    }\n\n    /**\n     * Return array of intersection points between polygon and other shape\n     * @param shape Shape of the one of supported types <br/>\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return intersectLine2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectCircle2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return intersectSegment2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectArc2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return intersectPolygon2Polygon(shape, this);\n        }\n    }\n\n    /**\n     * Returns new polygon translated by vector vec\n     * @param {Vector} vec\n     * @returns {Polygon}\n     */\n    translate(vec) {\n        let newPolygon = new Polygon();\n        for (let face of this.faces) {\n            newPolygon.addFace(face.shapes.map( shape => shape.translate(vec)));\n        }\n        return newPolygon;\n    }\n\n    /**\n     * Return new polygon rotated by given angle around given point\n     * If point omitted, rotate around origin (0,0)\n     * Positive value of angle defines rotation counter clockwise, negative - clockwise\n     * @param {number} angle - rotation angle in radians\n     * @param {Point} center - rotation center, default is (0,0)\n     * @returns {Polygon} - new rotated polygon\n     */\n    rotate(angle = 0, center = new Flatten.Point()) {\n        let newPolygon = new Polygon();\n        for (let face of this.faces) {\n            newPolygon.addFace(face.shapes.map( shape => shape.rotate(angle, center)));\n        }\n        return newPolygon;\n    }\n\n    /**\n     * Return new polygon transformed using affine transformation matrix\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Polygon} - new polygon\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        let newPolygon = new Polygon();\n        for (let face of this.faces) {\n            newPolygon.addFace(face.shapes.map( shape => shape.transform(matrix)));\n        }\n        return newPolygon;\n    }\n\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */\n    toJSON() {\n        return [...this.faces].map(face => face.toJSON());\n    }\n\n    /**\n     * Transform all faces into array of polygons\n     * @returns {Flatten.Polygon[]}\n     */\n    toArray() {\n        return [...this.faces].map(face => face.toPolygon());\n    }\n\n    /**\n     * Return string to draw polygon in svg\n     * @param attrs  - an object with attributes for svg path element,\n     * like \"stroke\", \"strokeWidth\", \"fill\", \"fillRule\", \"fillOpacity\"\n     * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"lightcyan\", fillRule:\"evenodd\", fillOpacity: \"1\"\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        let {stroke, strokeWidth, fill, fillRule, fillOpacity, id, className} = attrs;\n        // let restStr = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\n\n        let svgStr = `\\n<path stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"lightcyan\"}\" fill-rule=\"${fillRule || \"evenodd\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} d=\"`;\n        for (let face of this.faces) {\n            svgStr += face.svg();\n        }\n        svgStr += `\" >\\n</path>`;\n        return svgStr;\n    }\n}\n\nFlatten.Polygon = Polygon;\n\n/**\n * Shortcut method to create new polygon\n */\nconst polygon = (...args) => new Flatten.Polygon(...args);\nFlatten.polygon = polygon;\n\nclass Distance {\n    /**\n     * Calculate distance and shortest segment between points\n     * @param pt1\n     * @param pt2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2point(pt1, pt2) {\n        return pt1.distanceTo(pt2);\n    }\n\n    /**\n     * Calculate distance and shortest segment between point and line\n     * @param pt\n     * @param line\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2line(pt, line) {\n        let closest_point = pt.projectionOn(line);\n        let vec = new Flatten.Vector(pt, closest_point);\n        return [vec.length, new Flatten.Segment(pt, closest_point)];\n    }\n\n    /**\n     * Calculate distance and shortest segment between point and circle\n     * @param pt\n     * @param circle\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2circle(pt, circle) {\n        let [dist2center, shortest_dist] = pt.distanceTo(circle.center);\n        if (Flatten.Utils.EQ_0(dist2center)) {\n            return [circle.r, new Flatten.Segment(pt, circle.toArc().start)];\n        } else {\n            let dist = Math.abs(dist2center - circle.r);\n            let v = new Flatten.Vector(circle.pc, pt).normalize().multiply(circle.r);\n            let closest_point = circle.pc.translate(v);\n            return [dist, new Flatten.Segment(pt, closest_point)];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between point and segment\n     * @param pt\n     * @param segment\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2segment(pt, segment) {\n        /* Degenerated case of zero-length segment */\n        if (segment.start.equalTo(segment.end)) {\n            return Distance.point2point(pt, segment.start);\n        }\n\n        let v_seg = new Flatten.Vector(segment.start, segment.end);\n        let v_ps2pt = new Flatten.Vector(segment.start, pt);\n        let v_pe2pt = new Flatten.Vector(segment.end, pt);\n        let start_sp = v_seg.dot(v_ps2pt);\n        /* dot product v_seg * v_ps2pt */\n        let end_sp = -v_seg.dot(v_pe2pt);\n        /* minus dot product v_seg * v_pe2pt */\n\n        let dist;\n        let closest_point;\n        if (Flatten.Utils.GE(start_sp, 0) && Flatten.Utils.GE(end_sp, 0)) {    /* point inside segment scope */\n            let v_unit = segment.tangentInStart(); // new Flatten.Vector(v_seg.x / this.length, v_seg.y / this.length);\n            /* unit vector ||v_unit|| = 1 */\n            dist = Math.abs(v_unit.cross(v_ps2pt));\n            /* dist = abs(v_unit x v_ps2pt) */\n            closest_point = segment.start.translate(v_unit.multiply(v_unit.dot(v_ps2pt)));\n            return [dist, new Flatten.Segment(pt, closest_point)];\n        } else if (start_sp < 0) {                             /* point is out of scope closer to ps */\n            return pt.distanceTo(segment.start);\n        } else {                                               /* point is out of scope closer to pe */\n            return pt.distanceTo(segment.end);\n        }\n    };\n\n    /**\n     * Calculate distance and shortest segment between point and arc\n     * @param pt\n     * @param arc\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2arc(pt, arc) {\n        let circle = new Flatten.Circle(arc.pc, arc.r);\n        let dist_and_segment = [];\n        let dist, shortest_segment;\n        [dist, shortest_segment] = Distance.point2circle(pt, circle);\n        if (shortest_segment.end.on(arc)) {\n            dist_and_segment.push(Distance.point2circle(pt, circle));\n        }\n        dist_and_segment.push(Distance.point2point(pt, arc.start));\n        dist_and_segment.push(Distance.point2point(pt, arc.end));\n\n        Distance.sort(dist_and_segment);\n\n        return dist_and_segment[0];\n    }\n\n    /**\n     * Calculate distance and shortest segment between segment and line\n     * @param seg\n     * @param line\n     * @returns {Number | Segment}\n     */\n    static segment2line(seg, line) {\n        let ip = seg.intersect(line);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];   // distance = 0, closest point is the first point\n        }\n        let dist_and_segment = [];\n        dist_and_segment.push(Distance.point2line(seg.start, line));\n        dist_and_segment.push(Distance.point2line(seg.end, line));\n\n        Distance.sort(dist_and_segment);\n        return dist_and_segment[0];\n\n    }\n\n    /**\n     * Calculate distance and shortest segment between two segments\n     * @param seg1\n     * @param seg2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static segment2segment(seg1, seg2) {\n        let ip = intersectSegment2Segment(seg1, seg2);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];   // distance = 0, closest point is the first point\n        }\n\n        // Seg1 and seg2 not intersected\n        let dist_and_segment = [];\n        let dist_tmp, shortest_segment_tmp;\n        [dist_tmp, shortest_segment_tmp] = Distance.point2segment(seg2.start, seg1);\n        dist_and_segment.push([dist_tmp, shortest_segment_tmp.reverse()]);\n        [dist_tmp, shortest_segment_tmp] = Distance.point2segment(seg2.end, seg1);\n        dist_and_segment.push([dist_tmp, shortest_segment_tmp.reverse()]);\n        dist_and_segment.push(Distance.point2segment(seg1.start, seg2));\n        dist_and_segment.push(Distance.point2segment(seg1.end, seg2));\n\n        Distance.sort(dist_and_segment);\n        return dist_and_segment[0];\n    }\n\n    /**\n     * Calculate distance and shortest segment between segment and circle\n     * @param seg\n     * @param circle\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static segment2circle(seg, circle) {\n        /* Case 1 Segment and circle intersected. Return the first point and zero distance */\n        let ip = seg.intersect(circle);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        // No intersection between segment and circle\n\n        /* Case 2. Distance to projection of center point to line bigger than radius\n         * And projection point belong to segment\n          * Then measure again distance from projection to circle and return it */\n        let line = new Flatten.Line(seg.ps, seg.pe);\n        let [dist, shortest_segment] = Distance.point2line(circle.center, line);\n        if (Flatten.Utils.GE(dist, circle.r) && shortest_segment.end.on(seg)) {\n            return Distance.point2circle(shortest_segment.end, circle);\n        }\n        /* Case 3. Otherwise closest point is one of the end points of the segment */\n        else {\n            let [dist_from_start, shortest_segment_from_start] = Distance.point2circle(seg.start, circle);\n            let [dist_from_end, shortest_segment_from_end] = Distance.point2circle(seg.end, circle);\n            return Flatten.Utils.LT(dist_from_start, dist_from_end) ?\n                [dist_from_start, shortest_segment_from_start] :\n                [dist_from_end, shortest_segment_from_end];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between segment and arc\n     * @param seg\n     * @param arc\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static segment2arc(seg, arc) {\n        /* Case 1 Segment and arc intersected. Return the first point and zero distance */\n        let ip = seg.intersect(arc);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        // No intersection between segment and arc\n        let line = new Flatten.Line(seg.ps, seg.pe);\n        let circle = new Flatten.Circle(arc.pc, arc.r);\n\n        /* Case 2. Distance to projection of center point to line bigger than radius AND\n         * projection point belongs to segment AND\n           * distance from projection point to circle belongs to arc  =>\n           * return this distance from projection to circle */\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\n        if (Flatten.Utils.GE(dist_from_center, circle.r) && shortest_segment_from_center.end.on(seg)) {\n            let [dist_from_projection, shortest_segment_from_projection] =\n                Distance.point2circle(shortest_segment_from_center.end, circle);\n            if (shortest_segment_from_projection.end.on(arc)) {\n                return [dist_from_projection, shortest_segment_from_projection];\n            }\n        }\n        /* Case 3. Otherwise closest point is one of the end points of the segment */\n        let dist_and_segment = [];\n        dist_and_segment.push(Distance.point2arc(seg.start, arc));\n        dist_and_segment.push(Distance.point2arc(seg.end, arc));\n\n        let dist_tmp, segment_tmp;\n        [dist_tmp, segment_tmp] = Distance.point2segment(arc.start, seg);\n        dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n\n        [dist_tmp, segment_tmp] = Distance.point2segment(arc.end, seg);\n        dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n\n        Distance.sort(dist_and_segment);\n        return dist_and_segment[0];\n    }\n\n    /**\n     * Calculate distance and shortest segment between two circles\n     * @param circle1\n     * @param circle2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static circle2circle(circle1, circle2) {\n        let ip = circle1.intersect(circle2);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        // Case 1. Concentric circles. Convert to arcs and take distance between two arc starts\n        if (circle1.center.equalTo(circle2.center)) {\n            let arc1 = circle1.toArc();\n            let arc2 = circle2.toArc();\n            return Distance.point2point(arc1.start, arc2.start);\n        } else {\n            // Case 2. Not concentric circles\n            let line = new Flatten.Line(circle1.center, circle2.center);\n            let ip1 = line.intersect(circle1);\n            let ip2 = line.intersect(circle2);\n\n            let dist_and_segment = [];\n\n            dist_and_segment.push(Distance.point2point(ip1[0], ip2[0]));\n            dist_and_segment.push(Distance.point2point(ip1[0], ip2[1]));\n            dist_and_segment.push(Distance.point2point(ip1[1], ip2[0]));\n            dist_and_segment.push(Distance.point2point(ip1[1], ip2[1]));\n\n            Distance.sort(dist_and_segment);\n            return dist_and_segment[0];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between two circles\n     * @param circle\n     * @param line\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static circle2line(circle, line) {\n        let ip = circle.intersect(line);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\n        let [dist, shortest_segment] = Distance.point2circle(shortest_segment_from_center.end, circle);\n        shortest_segment = shortest_segment.reverse();\n        return [dist, shortest_segment];\n    }\n\n    /**\n     * Calculate distance and shortest segment between arc and line\n     * @param arc\n     * @param line\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static arc2line(arc, line) {\n        /* Case 1 Line and arc intersected. Return the first point and zero distance */\n        let ip = line.intersect(arc);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        let circle = new Flatten.Circle(arc.center, arc.r);\n\n        /* Case 2. Distance to projection of center point to line bigger than radius AND\n         * projection point belongs to segment AND\n           * distance from projection point to circle belongs to arc  =>\n           * return this distance from projection to circle */\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\n        if (Flatten.Utils.GE(dist_from_center, circle.r)) {\n            let [dist_from_projection, shortest_segment_from_projection] =\n                Distance.point2circle(shortest_segment_from_center.end, circle);\n            if (shortest_segment_from_projection.end.on(arc)) {\n                return [dist_from_projection, shortest_segment_from_projection];\n            }\n        } else {\n            let dist_and_segment = [];\n            dist_and_segment.push(Distance.point2line(arc.start, line));\n            dist_and_segment.push(Distance.point2line(arc.end, line));\n\n            Distance.sort(dist_and_segment);\n            return dist_and_segment[0];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between arc and circle\n     * @param arc\n     * @param circle2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static arc2circle(arc, circle2) {\n        let ip = arc.intersect(circle2);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        let circle1 = new Flatten.Circle(arc.center, arc.r);\n\n        let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\n        if (shortest_segment.start.on(arc)) {\n            return [dist, shortest_segment];\n        } else {\n            let dist_and_segment = [];\n\n            dist_and_segment.push(Distance.point2circle(arc.start, circle2));\n            dist_and_segment.push(Distance.point2circle(arc.end, circle2));\n\n            Distance.sort(dist_and_segment);\n\n            return dist_and_segment[0];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between two arcs\n     * @param arc1\n     * @param arc2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static arc2arc(arc1, arc2) {\n        let ip = arc1.intersect(arc2);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        let circle1 = new Flatten.Circle(arc1.center, arc1.r);\n        let circle2 = new Flatten.Circle(arc2.center, arc2.r);\n\n        let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\n        if (shortest_segment.start.on(arc1) && shortest_segment.end.on(arc2)) {\n            return [dist, shortest_segment];\n        } else {\n            let dist_and_segment = [];\n\n            let dist_tmp, segment_tmp;\n\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc1.start, arc2);\n            if (segment_tmp.end.on(arc2)) {\n                dist_and_segment.push([dist_tmp, segment_tmp]);\n            }\n\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc1.end, arc2);\n            if (segment_tmp.end.on(arc2)) {\n                dist_and_segment.push([dist_tmp, segment_tmp]);\n            }\n\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc2.start, arc1);\n            if (segment_tmp.end.on(arc1)) {\n                dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n            }\n\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc2.end, arc1);\n            if (segment_tmp.end.on(arc1)) {\n                dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n            }\n\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.start);\n            dist_and_segment.push([dist_tmp, segment_tmp]);\n\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.end);\n            dist_and_segment.push([dist_tmp, segment_tmp]);\n\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.start);\n            dist_and_segment.push([dist_tmp, segment_tmp]);\n\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.end);\n            dist_and_segment.push([dist_tmp, segment_tmp]);\n\n            Distance.sort(dist_and_segment);\n\n            return dist_and_segment[0];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between point and polygon\n     * @param point\n     * @param polygon\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2polygon(point, polygon) {\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n        for (let edge of polygon.edges) {\n            let [dist, shortest_segment] = (edge.shape instanceof Flatten.Segment) ?\n                Distance.point2segment(point, edge.shape) : Distance.point2arc(point, edge.shape);\n            if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n                min_dist_and_segment = [dist, shortest_segment];\n            }\n        }\n        return min_dist_and_segment;\n    }\n\n    static shape2polygon(shape, polygon) {\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n        for (let edge of polygon.edges) {\n            let [dist, shortest_segment] = shape.distanceTo(edge.shape);\n            if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n                min_dist_and_segment = [dist, shortest_segment];\n            }\n        }\n        return min_dist_and_segment;\n    }\n\n    /**\n     * Calculate distance and shortest segment between two polygons\n     * @param polygon1\n     * @param polygon2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static polygon2polygon(polygon1, polygon2) {\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n        for (let edge1 of polygon1.edges) {\n            for (let edge2 of polygon2.edges) {\n                let [dist, shortest_segment] = edge1.shape.distanceTo(edge2.shape);\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n                    min_dist_and_segment = [dist, shortest_segment];\n                }\n            }\n        }\n        return min_dist_and_segment;\n    }\n\n    /**\n     * Returns [mindist, maxdist] array of squared minimal and maximal distance between boxes\n     * Minimal distance by x is\n     *    (box2.xmin - box1.xmax), if box1 is left to box2\n     *    (box1.xmin - box2.xmax), if box2 is left to box1\n     *    0,                       if box1 and box2 are intersected by x\n     * Minimal distance by y is defined in the same way\n     *\n     * Maximal distance is estimated as a sum of squared dimensions of the merged box\n     *\n     * @param box1\n     * @param box2\n     * @returns {Number | Number} - minimal and maximal distance\n     */\n    static box2box_minmax(box1, box2) {\n        let mindist_x = Math.max(Math.max(box1.xmin - box2.xmax, 0), Math.max(box2.xmin - box1.xmax, 0));\n        let mindist_y = Math.max(Math.max(box1.ymin - box2.ymax, 0), Math.max(box2.ymin - box1.ymax, 0));\n        let mindist = mindist_x * mindist_x + mindist_y * mindist_y;\n\n        let box = box1.merge(box2);\n        let dx = box.xmax - box.xmin;\n        let dy = box.ymax - box.ymin;\n        let maxdist = dx * dx + dy * dy;\n\n        return [mindist, maxdist];\n    }\n\n    static minmax_tree_process_level(shape, level, min_stop, tree) {\n        // Calculate minmax distance to each shape in current level\n        // Insert result into the interval tree for further processing\n        // update min_stop with maxdist, it will be the new stop distance\n        let mindist, maxdist;\n        for (let node of level) {\n\n            // [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\n            // if (Flatten.Utils.GT(mindist, min_stop))\n            //     continue;\n\n            // Estimate min-max dist to the shape stored in the node.item, using node.item.key which is shape's box\n            [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.item.key);\n            if (node.item.value instanceof Flatten.Edge) {\n                tree.insert([mindist, maxdist], node.item.value.shape);\n            } else {\n                tree.insert([mindist, maxdist], node.item.value);\n            }\n            if (Flatten.Utils.LT(maxdist, min_stop)) {\n                min_stop = maxdist;                       // this will be the new distance estimation\n            }\n        }\n\n        if (level.length === 0)\n            return min_stop;\n\n        // Calculate new level from left and right children of the current\n        let new_level_left = level.map(node => node.left.isNil() ? undefined : node.left).filter(node => node !== undefined);\n        let new_level_right = level.map(node => node.right.isNil() ? undefined : node.right).filter(node => node !== undefined);\n        // Merge left and right subtrees and leave only relevant subtrees\n        let new_level = [...new_level_left, ...new_level_right].filter(node => {\n            // Node subtree quick reject, node.max is a subtree box\n            let [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\n            return (Flatten.Utils.LE(mindist, min_stop));\n        });\n\n        min_stop = Distance.minmax_tree_process_level(shape, new_level, min_stop, tree);\n        return min_stop;\n    }\n\n    /**\n     * Calculates sorted tree of [mindist, maxdist] intervals between query shape\n     * and shapes of the planar set.\n     * @param shape\n     * @param set\n     */\n    static minmax_tree(shape, set, min_stop) {\n        let tree = new IntervalTree();\n        let level = [set.index.root];\n        let squared_min_stop = min_stop < Number.POSITIVE_INFINITY ? min_stop * min_stop : Number.POSITIVE_INFINITY;\n        squared_min_stop = Distance.minmax_tree_process_level(shape, level, squared_min_stop, tree);\n        return tree;\n    }\n\n    static minmax_tree_calc_distance(shape, node, min_dist_and_segment) {\n        let min_dist_and_segment_new, stop;\n        if (node != null && !node.isNil()) {\n            [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.left, min_dist_and_segment);\n\n            if (stop) {\n                return [min_dist_and_segment_new, stop];\n            }\n\n            if (Flatten.Utils.LT(min_dist_and_segment_new[0], Math.sqrt(node.item.key.low))) {\n                return [min_dist_and_segment_new, true];   // stop condition\n            }\n\n            let [dist, shortest_segment] = Distance.distance(shape, node.item.value);\n            // console.log(dist)\n            if (Flatten.Utils.LT(dist, min_dist_and_segment_new[0])) {\n                min_dist_and_segment_new = [dist, shortest_segment];\n            }\n\n            [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.right, min_dist_and_segment_new);\n\n            return [min_dist_and_segment_new, stop];\n        }\n\n        return [min_dist_and_segment, false];\n    }\n\n    /**\n     * Calculates distance between shape and Planar Set of shapes\n     * @param shape\n     * @param {PlanarSet} set\n     * @param {Number} min_stop\n     * @returns {*}\n     */\n    static shape2planarSet(shape, set, min_stop = Number.POSITIVE_INFINITY) {\n        let min_dist_and_segment = [min_stop, new Flatten.Segment()];\n        let stop = false;\n        if (set instanceof Flatten.PlanarSet) {\n            let tree = Distance.minmax_tree(shape, set, min_stop);\n            [min_dist_and_segment, stop] = Distance.minmax_tree_calc_distance(shape, tree.root, min_dist_and_segment);\n        }\n        return min_dist_and_segment;\n    }\n\n    static sort(dist_and_segment) {\n        dist_and_segment.sort((d1, d2) => {\n            if (Flatten.Utils.LT(d1[0], d2[0])) {\n                return -1;\n            }\n            if (Flatten.Utils.GT(d1[0], d2[0])) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n\n    static distance(shape1, shape2) {\n        return shape1.distanceTo(shape2);\n    }\n}\n\nFlatten.Distance = Distance;\n\n/**\n * Created by Alex Bol on 3/7/2017.\n */\n\n/**\n * Inversion is a transformation of the Euclidean plane that maps generalized circles\n * (where line is considered as a circle with infinite radius) into generalized circles\n * See also https://en.wikipedia.org/wiki/Inversive_geometry and\n * http://mathworld.wolfram.com/Inversion.html <br/>\n * Inversion also may be considered as a reflection of the point in the plane with respect\n * to inversion circle so that R^2 = OP * OP',\n * where <br/>\n * O - center of inversion circle <br/>\n * R - radius of inversion circle <br/>\n * P - point of plane <br/>\n * P' - inversion of the point P\n *\n * @param {Line | Circle} shape - shape to be transformed\n * @param {Circle} inversion_circle - inversion circle\n * @returns {Line | Circle} - result of transformation\n */\nfunction inverse(shape, inversion_circle) {\n    let dist, shortest_segment;\n    let dx, dy;\n    let s;\n    let v;\n    let r;\n    let d;\n    let pt;\n\n    if (shape instanceof Flatten.Line) {\n        [dist, shortest_segment] = inversion_circle.pc.distanceTo(shape);\n        if (EQ_0(dist)) {            // Line passing through inversion center, is mapping to itself\n            return shape.clone();\n        } else {                           // Line not passing through inversion center is mapping into circle\n            r = inversion_circle.r * inversion_circle.r / (2 * dist);\n            v = new Flatten.Vector(inversion_circle.pc, shortest_segment.end);\n            v = v.multiply(r / dist);\n            return new Flatten.Circle(inversion_circle.pc.translate(v), r);\n        }\n    } else if (shape instanceof Flatten.Circle) {\n        [dist, shortest_segment] = inversion_circle.pc.distanceTo(shape.pc);\n        if (EQ(dist, shape.r)) {     // Circle passing through inversion center mapped into line\n            d = inversion_circle.r * inversion_circle.r / (2 * shape.r);\n            v = new Flatten.Vector(shape.pc, inversion_circle.pc);\n            v = v.normalize();\n            pt = inversion_circle.pc.translate(v.multiply(d));\n            return new Flatten.Line(pt, v);\n        } else {                           // Circle not passing through inversion center - map into another circle */\n            /* Taken from http://mathworld.wolfram.com */\n\n            dx = shape.pc.x - inversion_circle.pc.x;\n            dy = shape.pc.y - inversion_circle.pc.y;\n\n            s = inversion_circle.r * inversion_circle.r / (dx * dx + dy * dy - shape.r * shape.r);\n\n            let pc = new Flatten.Point(inversion_circle.pc.x + s * dx, inversion_circle.pc.y + s * dy);\n\n            return new Flatten.Circle(pc, Math.abs(s) * shape.r);\n        }\n    }\n}\n\n/**\n * Created by Alex Bol on 2/18/2017.\n */\n\nFlatten.BooleanOperations = BooleanOperations;\nFlatten.Relations = Relations;\n\nexport default Flatten;\nexport { Arc, BOUNDARY, BooleanOperations, Box, CCW, CW, Circle, Distance, Edge, errors as Errors, Face, INSIDE, Line, Matrix, Multiline, ORIENTATION, OUTSIDE, PlanarSet, Point, Polygon, Ray, Relations, Segment, Utils, Vector, arc, box, circle, inverse, line, matrix, multiline, point, polygon, ray, ray_shoot, segment, vector };\n", "import Flatten, { Arc, vector, Utils, Polygon, CW, CCW, Segment, Face, OUTSIDE, INSIDE, ORIENTATION } from '@flatten-js/core';\n\nfunction arcSE(center, start, end, counterClockwise) {\r\n    let startAngle = vector(center,start).slope;\r\n    let endAngle = vector(center, end).slope;\r\n    if (Utils.EQ(startAngle, endAngle)) {\r\n        endAngle += 2*Math.PI;\r\n        counterClockwise = true;\r\n    }\r\n    let r = vector(center, start).length;\r\n\r\n    return new Arc(center, r, startAngle, endAngle, counterClockwise);\r\n}\r\n\r\nfunction arcStartSweep(center, start, sweep, counterClockwise) {\r\n    let startAngle = vector(center,start).slope;\r\n    let endAngle = startAngle + sweep;\r\n    if (Utils.EQ(startAngle, endAngle)) {\r\n        endAngle += 2*Math.PI;\r\n        counterClockwise = true;\r\n    }\r\n    else if (Utils.GT(endAngle, 2*Math.PI)) {\r\n        endAngle -= 2*Math.PI;\r\n    }\r\n    else if (Utils.LT(endAngle, -2*Math.PI)) {\r\n        endAngle += 2*Math.PI;\r\n    }\r\n    let r = vector(center, start).length;\r\n\r\n    return new Arc(center, r, startAngle, endAngle, counterClockwise);\r\n}\r\n\r\nfunction arcEndSweep(center, end, sweep, counterClockwise) {\r\n    let endAngle = vector(center,end).slope;\r\n    let startAngle = endAngle - sweep;\r\n    if (Utils.EQ(startAngle, endAngle)) {\r\n        startAngle += 2*Math.PI;\r\n        counterClockwise = true;\r\n    }\r\n    else if (Utils.GT(startAngle, 2*Math.PI)) {\r\n        startAngle -= 2*Math.PI;\r\n    }\r\n    else if (Utils.LT(startAngle, -2*Math.PI)) {\r\n        startAngle += 2*Math.PI;\r\n    }\r\n\r\n    let r = vector(center, end).length;\r\n\r\n    return new Arc(center, r, startAngle, endAngle, counterClockwise);\r\n}\n\n/**\r\n * Created by Alex Bol on 12/02/2018.\r\n */\r\n\r\nconst {unify, subtract, BOOLEAN_UNION} = Flatten.BooleanOperations;\r\nconst {addToIntPoints, getSortedArray, splitByIntersections} = Flatten.BooleanOperations;\r\nconst {removeNotRelevantChains, removeOldFaces, restoreFaces} = Flatten.BooleanOperations;\r\n\r\n/**\r\n * Offset polygon by given value\r\n * @param {Polygon} polygon - input polygon\r\n * @param {number} value - offset value, may be positive or negative\r\n * @returns {Polygon} offsetPolygon\r\n */\r\n\r\n/**\r\n *\r\n * @param polygon\r\n * @param value\r\n *\r\n */\r\nfunction offset(polygon, value) {\r\n    let w = value;\r\n\r\n    let edges = [...polygon.edges];\r\n    let offsetPolygon = polygon.clone();\r\n    let offsetEdge;\r\n\r\n    if (w != 0) {\r\n        // let counter = 0\r\n        for (let edge of edges) {\r\n            if (edge.isSegment()) {\r\n                offsetEdge = offsetSegment(edge.shape, w);\r\n            }\r\n            else {\r\n                offsetEdge = offsetArc(edge.shape, w);\r\n            }\r\n\r\n            if (w > 0) {\r\n                offsetPolygon = unify(offsetPolygon, offsetEdge);\r\n            }\r\n            else {\r\n                offsetPolygon = subtract(offsetPolygon, offsetEdge);\r\n            }\r\n            // counter++;\r\n        }\r\n    }\r\n\r\n    return offsetPolygon;\r\n}\r\n\r\nfunction offsetArc(arc, value) {\r\n\r\n    let w = Math.abs(value);\r\n\r\n    // Define outline polygon\r\n    let polygon = new Polygon();\r\n    let arc_cap1,arc_cap2;\r\n\r\n    let arc_outer = arc.clone();\r\n    arc_outer.r = arc.r + w;\r\n\r\n    arc_cap1 = arcStartSweep(arc.end, arc_outer.end, Math.PI, arc.counterClockwise);\r\n    arc_cap2 = arcEndSweep(arc.start, arc_outer.start, Math.PI, arc.counterClockwise);\r\n\r\n    let arc_inner = undefined;\r\n    if (arc.r > w) {\r\n        arc_inner = new Arc(arc.pc, arc.r - w, arc.endAngle, arc.startAngle,\r\n            arc.counterClockwise === CW ? CCW : CW);\r\n    }\r\n    else {\r\n        // arc_inner = new Arc(arc.pc, w - arc.r, arc.startAngle, arc.endAngle, arc.counterClockwise);\r\n        arc_inner = new Segment(arc_cap1.end, arc_cap2.start);\r\n    }\r\n\r\n    polygon.addFace([arc_outer, arc_cap1, arc_inner, arc_cap2]);\r\n    [...polygon.faces][0].setArcLength();\r\n\r\n    // Create intersection points\r\n    let ips = Face.getSelfIntersections([...polygon.faces][0], polygon.edges, false);\r\n\r\n    // TODO: getSelfIntersections returns points with correspondent edges - avoid duplication\r\n    ips = ips.slice(0,ips.length/2);    // for now slice array to avoid duplication in points\r\n\r\n    let int_points = [];\r\n    let edge_cap1;\r\n    let edge_cap2;\r\n\r\n    edge_cap1 = [...polygon.edges][1];\r\n    edge_cap2 = [...polygon.edges][3];\r\n\r\n    for (let pt of ips) {\r\n        addToIntPoints(edge_cap1, pt, int_points);\r\n        addToIntPoints(edge_cap2, pt, int_points);\r\n    }\r\n\r\n    // Sort intersection points and insert them as new vertices\r\n    let int_points_sorted = getSortedArray(int_points);\r\n    splitByIntersections(polygon, int_points_sorted);\r\n\r\n\r\n    // Set BV flags\r\n    let bv = OUTSIDE;\r\n    for (let int_point of int_points_sorted) {\r\n        int_point.edge_before.bv = bv;\r\n        int_point.edge_after.bv = (bv == OUTSIDE ? INSIDE : OUTSIDE);\r\n        bv = int_point.edge_after.bv;   // invert flag on each iteration\r\n    }\r\n\r\n    // Remove inner \"chains\"\r\n    let op = BOOLEAN_UNION;\r\n    removeNotRelevantChains(polygon, op, int_points_sorted, true);\r\n\r\n    // return int_points_sorted;\r\n    // Swap links\r\n    let num = int_points.length;\r\n    if (num > 0) {\r\n        let edge_before;\r\n        let edge_after;\r\n        // 0 => 3\r\n        edge_before = int_points_sorted[0].edge_before;\r\n        edge_after = int_points_sorted[num-1].edge_after;\r\n        edge_before.next = edge_after;\r\n        edge_after.prev = edge_before;\r\n\r\n        // Fill in missed links in intersection points\r\n        int_points_sorted[0].edge_after = int_points_sorted[num-1].edge_after;\r\n        int_points_sorted[num-1].edge_before = int_points_sorted[0].edge_before;\r\n\r\n        if (num == 4) {\r\n            // 2 => 1\r\n            edge_before = int_points_sorted[2].edge_before;\r\n            edge_after = int_points_sorted[1].edge_after;\r\n            edge_before.next = edge_after;\r\n            edge_after.prev = edge_before;\r\n\r\n            // Fill in missed links in intersection points\r\n            int_points_sorted[2].edge_after = int_points_sorted[1].edge_after;\r\n            int_points_sorted[1].edge_before = int_points_sorted[2].edge_before;\r\n        }\r\n\r\n        // remove old faces\r\n        removeOldFaces(polygon, int_points);\r\n        // restore faces\r\n        restoreFaces(polygon, int_points, int_points);\r\n    }\r\n\r\n    let face0 = [...polygon.faces][0];\r\n    if (face0.orientation() === ORIENTATION.CCW) {\r\n        polygon.reverse();\r\n    }\r\n    return polygon;\r\n}\r\n\r\nfunction offsetSegment(seg, value) {\r\n    let w = Math.abs(value);\r\n\r\n    let polygon = new Polygon();\r\n    let v_seg = vector(seg.end.x-seg.start.x, seg.end.y-seg.start.y);\r\n    let v_seg_unit = v_seg.normalize();\r\n    let v_left = v_seg_unit.rotate90CCW().multiply(w);\r\n    let v_right = v_seg_unit.rotate90CW().multiply(w);\r\n    let seg_left = seg.translate(v_left);\r\n    let seg_right = seg.translate(v_right).reverse();\r\n    let cap1 = arcSE(seg.end, seg_left.end, seg_right.start, CW);\r\n    let cap2 = arcSE(seg.start, seg_right.end, seg_left.start, CW);\r\n\r\n    polygon.addFace([seg_left, cap1, seg_right, cap2]);\r\n    return polygon;\r\n}\n\nexport default offset;\n", "import { Point, Polygon } from \"@flatten-js/core\";\nimport offset from \"@flatten-js/polygon-offset\";\n\n(async () => {\n  const scene = AFRAME.scenes[0].object3D;\n\n  async function makeMesh(inset) {\n    const origin = new THREE.Vector2();\n    const radius = 1;\n    const config = {\n      holeSize: 1,\n    };\n\n    const paths = await new Promise((resolve) => {\n      new THREE.SVGLoader().load(\"/winter.svg\", (svg) => {\n        resolve(svg.paths);\n      });\n    });\n\n    const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    svg.setAttribute(\"viewBox\", \"0 0 300 300\");\n    svgs.append(svg);\n\n    const shapes = paths\n      .flatMap((p) => p.toShapes())\n      .map((s) => {\n        const polygon = new Polygon();\n        polygon.addFace(s.getPoints(6).map((p) => new Point(p.x, p.y)));\n        objURL = URL.createObjectURL(new Blob([JSON.stringify(polygon.toJSON())], {type: \"application/json\"}));\n        document.body.innerHTML += `<a href=\"${objURL}\">download</a>`;\n\n        let finalPolygon;\n        if (inset) {\n          finalPolygon = offset(polygon, inset);\n        } else {\n          finalPolygon = polygon;\n        }\n\n        svg.innerHTML += finalPolygon.svg();\n\n        return new THREE.Shape(finalPolygon.vertices);\n      });\n\n    const geo = new THREE.ExtrudeGeometry(shapes, { curveSegments: 3, depth: radius * 1, bevelEnabled: false });\n\n    // geo.computeBoundingBox();\n    // const size = new THREE.Vector3();\n    // geo.boundingBox.getSize(size);\n\n    // const mat4 = new THREE.Matrix4();\n    // if (size.x > size.y) {\n    //   mat4.makeScale(config.holeSize / size.x, (config.holeSize / size.x) * (size.y / size.x), radius * 1);\n    // } else {\n    //   mat4.makeScale((config.holeSize / size.y) * (size.x / size.y), config.holeSize / size.y, radius * 1);\n    // }\n    // geo.applyMatrix(mat4);\n    // mat4.makeScale(1, -1, -1);\n    // geo.applyMatrix(mat4);\n\n    // geo.computeBoundingBox();\n    // geo.center();\n\n    const mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: inset ? \"red\" : \"grey\", wireframe: false }));\n\n    mesh.scale.setScalar(0.01);\n\n    return mesh;\n  }\n\n  const outer = await makeMesh();\n  scene.add(outer);\n  // const inner = await makeMesh(-4);\n  // inner.position.z = 0.01;\n  // scene.add(inner);\n})();\n"],
  "mappings": "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",
  "names": []
}
